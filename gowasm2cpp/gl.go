// SPDX-License-Identifier: Apache-2.0

package gowasm2cpp

import (
	"os"
	"path/filepath"
	"text/template"
)

func writeGL(dir string, incpath string, namespace string) error {
	{
		f, err := os.Create(filepath.Join(dir, "gl.h"))
		if err != nil {
			return err
		}
		defer f.Close()

		if err := glHTmpl.Execute(f, struct {
			IncludeGuard string
			IncludePath  string
			Namespace    string
		}{
			IncludeGuard: includeGuard(namespace) + "_GL_H",
			IncludePath:  incpath,
			Namespace:    namespace,
		}); err != nil {
			return err
		}
	}
	{
		f, err := os.Create(filepath.Join(dir, "gl.cpp"))
		if err != nil {
			return err
		}
		defer f.Close()

		if err := glCppTmpl.Execute(f, struct {
			IncludePath string
			Namespace   string
		}{
			IncludePath: incpath,
			Namespace:   namespace,
		}); err != nil {
			return err
		}
	}
	return nil
}

var glHTmpl = template.Must(template.New("gl.h").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#ifndef {{.IncludeGuard}}
#define {{.IncludeGuard}}

#include "{{.IncludePath}}js.h"

#include <functional>

namespace {{.Namespace}} {

// GL emulates WebGLRenderingContext by OpenGL (not ES).
class GL : public Object {
public:
  explicit GL(std::function<void*(const char*)> func);
  Value Get(const std::string &key) override;
  std::string ToString() const override;

private:
  // TODO: Now this covers GL 1.x functions.
  // Get the proc addresses for all the GL functions?
  void *glActiveTexture_;
  void *glAttachShader_;
  void *glBindAttribLocation_;
  void *glBindBuffer_;
  void *glBindFramebuffer_;
  void *glBindTexture_;
  void *glBlendFunc_;
  void *glBufferData_;
  void *glBufferSubData_;
  void *glCheckFramebufferStatus_;
  void *glCompileShader_;
  void *glCreateProgram_;
  void *glCreateShader_;
  void *glDeleteBuffers_;
  void *glDeleteFramebuffers_;
  void *glDeleteProgram_;
  void *glDeleteShader_;
  void *glDeleteTextures_;
  void *glDisableVertexAttribArray_;
  void *glDrawElements_;
  void *glEnable_;
  void *glEnableVertexAttribArray_;
  void *glFlush_;
  void *glFramebufferTexture2D_;
  void *glGenBuffers_;
  void *glGenFramebuffers_;
  void *glGenTextures_;
  void *glGetError_;
  void *glGetIntegerv_;
  void *glGetProgramInfoLog_;
  void *glGetProgramiv_;
  void *glGetShaderInfoLog_;
  void *glGetShaderiv_;
  void *glGetUniformLocation_;
  void *glIsFramebuffer_;
  void *glIsProgram_;
  void *glIsTexture_;
  void *glLinkProgram_;
  void *glPixelStorei_;
  void *glReadPixels_;
  void *glScissor_;
  void *glShaderSource_;
  void *glTexImage2D_;
  void *glTexParameteri_;
  void *glTexSubImage2D_;
  void *glUniform1f_;
  void *glUniform1fv_;
  void *glUniform1i_;
  void *glUniform2fv_;
  void *glUniform3fv_;
  void *glUniform4fv_;
  void *glUniformMatrix2fv_;
  void *glUniformMatrix3fv_;
  void *glUniformMatrix4fv_;
  void *glUseProgram_;
  void *glVertexAttribPointer_;
  void *glViewport_;
};

}

#endif  // {{.IncludeGuard}}
`))

var glCppTmpl = template.Must(template.New("gl.cpp").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#include "{{.IncludePath}}gl.h"

#include "{{.IncludePath}}js.h"

#if defined(__APPLE__)
# define GL_SILENCE_DEPRECATION
# include <OpenGL/gl.h>
#else
# include <GL/gl.h>
#endif

namespace {{.Namespace}} {

GL::GL(std::function<void*(const char*)> get_proc_address) {
  glActiveTexture_ = get_proc_address("glActiveTexture");
  glAttachShader_ = get_proc_address("glAttachShader");
  glBindAttribLocation_ = get_proc_address("glBindAttribLocation");
  glBindBuffer_ = get_proc_address("glBindBuffer");
  glBindFramebuffer_ = get_proc_address("glBindFramebuffer");
  glBindTexture_ = get_proc_address("glBindTexture");
  glBlendFunc_ = get_proc_address("glBlendFunc");
  glBufferData_ = get_proc_address("glBufferData");
  glBufferSubData_ = get_proc_address("glBufferSubData");
  glCheckFramebufferStatus_ = get_proc_address("glCheckFramebufferStatus");
  glCompileShader_ = get_proc_address("glCompileShader");
  glCreateProgram_ = get_proc_address("glCreateProgram");
  glCreateShader_ = get_proc_address("glCreateShader");
  glDeleteBuffers_ = get_proc_address("glDeleteBuffers");
  glDeleteFramebuffers_ = get_proc_address("glDeleteFramebuffers");
  glDeleteProgram_ = get_proc_address("glDeleteProgram");
  glDeleteShader_ = get_proc_address("glDeleteShader");
  glDeleteTextures_ = get_proc_address("glDeleteTextures");
  glDisableVertexAttribArray_ = get_proc_address("glDisableVertexAttribArray");
  glDrawElements_ = get_proc_address("glDrawElements");
  glEnable_ = get_proc_address("glEnable");
  glEnableVertexAttribArray_ = get_proc_address("glEnableVertexAttribArray");
  glFlush_ = get_proc_address("glFlush");
  glFramebufferTexture2D_ = get_proc_address("glFramebufferTexture2D");
  glGenBuffers_ = get_proc_address("glGenBuffers");
  glGenFramebuffers_ = get_proc_address("glGenFramebuffers");
  glGenTextures_ = get_proc_address("glGenTextures");
  glGetError_ = get_proc_address("glGetError");
  glGetIntegerv_ = get_proc_address("glGetIntegerv");
  glGetProgramInfoLog_ = get_proc_address("glGetProgramInfoLog");
  glGetProgramiv_ = get_proc_address("glGetProgramiv");
  glGetShaderInfoLog_ = get_proc_address("glGetShaderInfoLog");
  glGetShaderiv_ = get_proc_address("glGetShaderiv");
  glGetUniformLocation_ = get_proc_address("glGetUniformLocation");
  glIsFramebuffer_ = get_proc_address("glIsFramebuffer");
  glIsProgram_ = get_proc_address("glIsProgram");
  glIsTexture_ = get_proc_address("glIsTexture");
  glLinkProgram_ = get_proc_address("glLinkProgram");
  glPixelStorei_ = get_proc_address("glPixelStorei");
  glReadPixels_ = get_proc_address("glReadPixels");
  glScissor_ = get_proc_address("glScissor");
  glShaderSource_ = get_proc_address("glShaderSource");
  glTexImage2D_ = get_proc_address("glTexImage2D");
  glTexParameteri_ = get_proc_address("glTexParameteri");
  glTexSubImage2D_ = get_proc_address("glTexSubImage2D");
  glUniform1f_ = get_proc_address("glUniform1f");
  glUniform1fv_ = get_proc_address("glUniform1fv");
  glUniform1i_ = get_proc_address("glUniform1i");
  glUniform2fv_ = get_proc_address("glUniform2fv");
  glUniform3fv_ = get_proc_address("glUniform3fv");
  glUniform4fv_ = get_proc_address("glUniform4fv");
  glUniformMatrix2fv_ = get_proc_address("glUniformMatrix2fv");
  glUniformMatrix3fv_ = get_proc_address("glUniformMatrix3fv");
  glUniformMatrix4fv_ = get_proc_address("glUniformMatrix4fv");
  glUseProgram_ = get_proc_address("glUseProgram");
  glVertexAttribPointer_ = get_proc_address("glVertexAttribPointer");
  glViewport_ = get_proc_address("glViewport");
}

Value GL::Get(const std::string &key) {
  if (key == "activeTexture") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLenum texture = static_cast<GLenum>(args[0].ToNumber());
          using f = void(*)(GLenum texture);
          reinterpret_cast<f>(glActiveTexture_)(texture);
          return Value{};
        })};
  }
  if (key == "attachShader") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint program = static_cast<GLuint>(args[0].ToNumber());
          GLuint shader = static_cast<GLuint>(args[1].ToNumber());
          using f = void(*)(GLuint, GLuint);
          reinterpret_cast<f>(glAttachShader_)(program, shader);
          return Value{};
        })};
  }
  if (key == "bindAttribLocation") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint program = static_cast<GLuint>(args[0].ToNumber());
          GLuint index = static_cast<GLuint>(args[1].ToNumber());
          std::string name = args[2].ToString();
          using f = void(*)(GLuint, GLuint, const GLchar*);
          reinterpret_cast<f>(glBindAttribLocation_)(
              program, index, const_cast<GLchar *>(name.c_str()));
          return Value{};
        })};
  }
  if (key == "bindBuffer") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLenum target = static_cast<GLenum>(args[0].ToNumber());
          GLuint buffer = static_cast<GLuint>(args[1].ToNumber());
          using f = void(*)(GLenum, GLuint);
          reinterpret_cast<f>(glBindBuffer_)(target, buffer);
          return Value{};
        })};
  }
  if (key == "bindFramebuffer") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLenum target = static_cast<GLenum>(args[0].ToNumber());
          GLuint framebuffer = static_cast<GLuint>(args[1].ToNumber());
          using f = void(*)(GLenum, GLuint);
          reinterpret_cast<f>(glBindFramebuffer_)(target, framebuffer);
          return Value{};
        })};
  }
  if (key == "bindTexture") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLenum target = static_cast<GLenum>(args[0].ToNumber());
          GLuint texture = static_cast<GLuint>(args[1].ToNumber());
          using f = void(*)(GLenum, GLuint);
          reinterpret_cast<f>(glBindTexture_)(target, texture);
          return Value{};
        })};
  }
  if (key == "blendFunc") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLenum sfactor = static_cast<GLenum>(args[0].ToNumber());
          GLenum dfactor = static_cast<GLenum>(args[1].ToNumber());
          using f = void(*)(GLenum, GLenum);
          reinterpret_cast<f>(glBlendFunc_)(sfactor, dfactor);
          return Value{};
        })};
  }
  if (key == "bufferData") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLenum target = static_cast<GLenum>(args[0].ToNumber());
          GLsizeiptr size = static_cast<GLsizeiptr>(args[1].ToNumber());
          void* data = nullptr;
          GLenum usage = static_cast<GLenum>(args[2].ToNumber());
          using f = void(*)(GLenum, GLsizeiptr, const void*, GLenum);
          reinterpret_cast<f>(glBufferData_)(target, size, data, usage);
          return Value{};
        })};
  }
  if (key == "bufferSubData") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLenum target = static_cast<GLenum>(args[0].ToNumber());
          GLintptr offset = static_cast<GLintptr>(args[1].ToNumber());
          BytesSpan data = args[2].ToBytes();
          using f = void(*)(GLenum, GLintptr, GLsizeiptr, const void*);
          reinterpret_cast<f>(glBufferSubData_)(target, offset, data.size(), data.begin());
          return Value{};
        })};
  }
  if (key == "checkFramebufferStatus") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLenum target = static_cast<GLenum>(args[0].ToNumber());
          using f = GLenum(*)(GLenum);
          GLenum status = reinterpret_cast<f>(glCheckFramebufferStatus_)(target);
          return Value{static_cast<double>(status)};
        })};
  }
  if (key == "compileShader") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint shader = static_cast<GLuint>(args[0].ToNumber());
          using f = void(*)(GLuint);
          reinterpret_cast<f>(glCompileShader_)(shader);
          return Value{};
        })};
  }
  if (key == "createBuffer") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint buffer;
          using f = void(*)(GLsizei, GLuint*);
          reinterpret_cast<f>(glGenBuffers_)(1, &buffer);
          return Value{static_cast<double>(buffer)};
        })};
  }
  if (key == "createFramebuffer") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint framebuffer;
          using f = void(*)(GLsizei, GLuint*);
          reinterpret_cast<f>(glGenFramebuffers_)(1, &framebuffer);
          return Value{static_cast<double>(framebuffer)};
        })};
  }
  if (key == "createProgram") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          using f = GLuint(*)();
          GLuint program = reinterpret_cast<f>(glCreateProgram_)();
          return Value{static_cast<double>(program)};
        })};
  }
  if (key == "createShader") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLenum shaderType = static_cast<GLenum>(args[0].ToNumber());
          using f = GLuint(*)(GLenum);
          GLuint shader = reinterpret_cast<f>(glCreateShader_)(shaderType);
          return Value{static_cast<double>(shader)};
        })};
  }
  if (key == "createTexture") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint texture;
          using f = void(*)(GLsizei, GLuint*);
          reinterpret_cast<f>(glGenTextures_)(1, &texture);
          return Value{static_cast<double>(texture)};
        })};
  }
  if (key == "deleteBuffer") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint buffer = static_cast<GLuint>(args[0].ToNumber());
          using f = void(*)(GLsizei, GLuint*);
          reinterpret_cast<f>(glDeleteBuffers_)(1, &buffer);
          return Value{};
        })};
  }
  if (key == "deleteFramebuffer") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint framebuffer = static_cast<GLuint>(args[0].ToNumber());
          using f = void(*)(GLsizei, GLuint*);
          reinterpret_cast<f>(glDeleteFramebuffers_)(1, &framebuffer);
          return Value{};
        })};
  }
  if (key == "deleteProgram") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint program = static_cast<GLuint>(args[0].ToNumber());
          using f = void(*)(GLuint);
          reinterpret_cast<f>(glDeleteProgram_)(program);
          return Value{};
        })};
  }
  if (key == "deleteShader") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint shader = static_cast<GLuint>(args[0].ToNumber());
          using f = void(*)(GLuint);
          reinterpret_cast<f>(glDeleteShader_)(shader);
          return Value{};
        })};
  }
  if (key == "deleteTexture") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint texture = static_cast<GLuint>(args[0].ToNumber());
          using f = void(*)(GLsizei, GLuint*);
          reinterpret_cast<f>(glDeleteTextures_)(1, &texture);
          return Value{};
        })};
  }
  if (key == "disableVertexAttribArray") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint index = static_cast<GLuint>(args[0].ToNumber());
          using f = void(*)(GLuint);
          reinterpret_cast<f>(glDisableVertexAttribArray_)(index);
          return Value{};
        })};
  }
  if (key == "drawElements") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLenum mode = static_cast<GLenum>(args[0].ToNumber());
          GLsizei count = static_cast<GLsizei>(args[1].ToNumber());
          GLenum type = static_cast<GLenum>(args[2].ToNumber());
          void *indices = nullptr;
          if (args[3].IsNumber()) {
            indices = reinterpret_cast<void *>(
                static_cast<uintptr_t>(args[3].ToNumber()));
          }
          if (args[3].IsBytes()) {
            indices = args[3].ToBytes().begin();
          }
          using f = void(*)(GLenum, GLsizei, GLenum, const void*);
          reinterpret_cast<f>(glDrawElements_)(mode, count, type, indices);
          return Value{};
        })};
  }
  if (key == "enable") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLenum cap = static_cast<GLenum>(args[0].ToNumber());
          using f = void(*)(GLenum);
          reinterpret_cast<f>(glEnable_)(cap);
          return Value{};
        })};
  }
  if (key == "enableVertexAttribArray") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint index = static_cast<GLuint>(args[0].ToNumber());
          using f = void(*)(GLuint);
          reinterpret_cast<f>(glEnableVertexAttribArray_)(index);
          return Value{};
        })};
  }
  if (key == "flush") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          using f = void(*)();
          reinterpret_cast<f>(glFlush_)();
          return Value{};
        })};
  }
  if (key == "framebufferTexture2D") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLenum target = static_cast<GLenum>(args[0].ToNumber());
          GLenum attachment = static_cast<GLenum>(args[1].ToNumber());
          GLenum textarget = static_cast<GLenum>(args[2].ToNumber());
          GLuint texture = static_cast<GLuint>(args[3].ToNumber());
          GLint level = static_cast<GLint>(args[4].ToNumber());
          using f = void(*)(GLenum, GLenum, GLenum, GLuint, GLint);
          reinterpret_cast<f>(glFramebufferTexture2D_)(
              target, attachment, textarget, texture, level);
          return Value{};
        })};
  }
  if (key == "getError") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          using f = GLenum(*)();
          GLenum error = reinterpret_cast<f>(glGetError_)();
          return Value{static_cast<double>(error)};
        })};
  }
  if (key == "getExtension") {
    return Value{std::make_shared<FuncObject>(
        [](Value self, std::vector<Value> args) -> Value {
          // Do nothing.
          return Value{};
        })};
  }
  if (key == "getParameter") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLenum pname = static_cast<GLenum>(args[0].ToNumber());
          GLint data;
          using f = void(*)(GLenum, GLint*);
          reinterpret_cast<f>(glGetIntegerv_)(pname, &data);
          return Value{static_cast<double>(data)};
        })};
  }
  if (key == "getProgramInfoLog") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint program = static_cast<GLuint>(args[0].ToNumber());
          GLint buflen;
          using f1 = void(*)(GLuint, GLenum, GLint*);
          reinterpret_cast<f1>(glGetProgramiv_)(program, GL_INFO_LOG_LENGTH, &buflen);

          GLint len;
          std::vector<GLchar> buf = std::vector<GLchar>(buflen);
          using f2 = void(*)(GLuint, GLsizei, GLsizei*, GLchar*);
          reinterpret_cast<f2>(glGetProgramInfoLog_)(program, buflen, &len, buf.data());
          std::string log = std::string(buf.begin(), buf.begin() + len);
          return Value{log};
        })};
  }
  if (key == "getProgramParameter") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint program = static_cast<GLuint>(args[0].ToNumber());
          GLenum pname = static_cast<GLenum>(args[1].ToNumber());
          GLint params;
          using f = void(*)(GLuint, GLenum, GLint*);
          reinterpret_cast<f>(glGetProgramiv_)(program, pname, &params);
          switch (pname) {
          case GL_DELETE_STATUS:
          case GL_LINK_STATUS:
          case GL_VALIDATE_STATUS:
            return Value{static_cast<bool>(params)};
          default:
            return Value{static_cast<double>(params)};
          }
        })};
  }
  if (key == "getShaderInfoLog") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint shader = static_cast<GLuint>(args[0].ToNumber());
          GLint buflen;
          using f1 = void(*)(GLuint, GLenum, GLint*);
          reinterpret_cast<f1>(glGetShaderiv_)(shader, GL_INFO_LOG_LENGTH, &buflen);

          GLint len;
          std::vector<GLchar> buf = std::vector<GLchar>(buflen);
          using f2 = void(*)(GLuint, GLsizei, GLsizei*, GLchar*);
          reinterpret_cast<f2>(glGetShaderInfoLog_)(shader, buflen, &len, buf.data());
          std::string log = std::string(buf.begin(), buf.begin() + len);
          return Value{log};
      })};
  }
  if (key == "getShaderParameter") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint shader = static_cast<GLuint>(args[0].ToNumber());
          GLenum pname = static_cast<GLenum>(args[1].ToNumber());
          GLint params;
          using f = void(*)(GLuint, GLenum, GLint*);
          reinterpret_cast<f>(glGetShaderiv_)(shader, pname, &params);
          switch (pname) {
          case GL_DELETE_STATUS:
          case GL_COMPILE_STATUS:
            return Value{static_cast<bool>(params)};
          default:
            return Value{static_cast<double>(params)};
          }
        })};
  }
  if (key == "getShaderPrecisionFormat") {
    return Value{std::make_shared<FuncObject>(
        [](Value self, std::vector<Value> args) -> Value {
          GLenum shaderType = static_cast<GLenum>(args[0].ToNumber());
          GLenum precisionType = static_cast<GLenum>(args[1].ToNumber());
          if (shaderType != GL_FRAGMENT_SHADER) {
            return Value{};
          }
          if (precisionType != 0x8DF2 /* GL_HIGH_FLOAT */) {
            return Value{};
          }

          // glGetShaderPrecisionFormat is only for OpenGL ES.
          // Assume that the precision is always enough.
          auto obj = std::make_shared<DictionaryValues>();
          obj->Set("rangeMin", Value{static_cast<double>(127)});
          obj->Set("rangeMax", Value{static_cast<double>(127)});
          obj->Set("precision", Value{static_cast<double>(23)});
          return Value{obj};
        })};
}
  if (key == "getUniformLocation") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint program = static_cast<GLuint>(args[0].ToNumber());
          std::string name = args[1].ToString();
          using f = GLint(*)(GLuint, const GLchar*);
          GLint location = reinterpret_cast<f>(glGetUniformLocation_)(program, name.c_str());
          return Value{static_cast<double>(location)};
        })};
  }
  if (key == "isContextLost") {
    return Value{std::make_shared<FuncObject>(
        [](Value self, std::vector<Value> args) -> Value {
          return Value{false};
        })};
  }
  if (key == "isFramebuffer") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint framebuffer = static_cast<GLuint>(args[0].ToNumber());
          using f = GLboolean(*)(GLuint);
          bool result = reinterpret_cast<f>(glIsFramebuffer_)(framebuffer) == GL_TRUE;
          return Value{result};
        })};
  }
  if (key == "isProgram") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint program = static_cast<GLuint>(args[0].ToNumber());
          using f = GLboolean(*)(GLuint);
          bool result = reinterpret_cast<f>(glIsProgram_)(program) == GL_TRUE;
          return Value{result};
        })};
  }
  if (key == "isTexture") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint texture = static_cast<GLuint>(args[0].ToNumber());
          using f = GLboolean(*)(GLuint);
          bool result = reinterpret_cast<f>(glIsTexture_)(texture) == GL_TRUE;
          return Value{result};
        })};
  }
  if (key == "linkProgram") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint program = static_cast<GLuint>(args[0].ToNumber());
          using f = void(*)(GLuint);
          reinterpret_cast<f>(glLinkProgram_)(program);
          return Value{};
        })};
  }
  if (key == "pixelStorei") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLenum pname = static_cast<GLenum>(args[0].ToNumber());
          GLint param = static_cast<GLint>(args[1].ToNumber());
          using f = void(*)(GLenum, GLint);
          reinterpret_cast<f>(glPixelStorei_)(pname, param);
          return Value{};
        })};
  }
  if (key == "readPixels") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLint x = static_cast<GLint>(args[0].ToNumber());
          GLint y = static_cast<GLint>(args[1].ToNumber());
          GLsizei width = static_cast<GLsizei>(args[2].ToNumber());
          GLsizei height = static_cast<GLsizei>(args[3].ToNumber());
          GLenum format = static_cast<GLenum>(args[4].ToNumber());
          GLenum type = static_cast<GLenum>(args[5].ToNumber());
          void *data = nullptr;
          if (args[6].IsNumber()) {
            data = reinterpret_cast<void *>(
                static_cast<uintptr_t>(args[6].ToNumber()));
          }
          if (args[6].IsBytes()) {
            data = args[6].ToBytes().begin();
          }
          using f = void(*)(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, void*);
          reinterpret_cast<f>(glReadPixels_)(x, y, width, height, format, type, data);
          return Value{};
        })};
  }
  if (key == "scissor") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLint x = static_cast<GLint>(args[0].ToNumber());
          GLint y = static_cast<GLint>(args[1].ToNumber());
          GLsizei width = static_cast<GLsizei>(args[2].ToNumber());
          GLsizei height = static_cast<GLsizei>(args[3].ToNumber());
          using f = void(*)(GLint, GLint, GLsizei, GLsizei);
          reinterpret_cast<f>(glScissor_)(x, y, width, height);
          return Value{};
        })};
  }
  if (key == "shaderSource") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint shader = static_cast<GLuint>(args[0].ToNumber());
          std::string str = args[1].ToString();
          const char *cstr = str.c_str();
          using f = void(*)(GLuint, GLsizei, const GLchar**, const GLint*);
          reinterpret_cast<f>(glShaderSource_)(shader, 1, &cstr, nullptr);
          return Value{};
        })};
  }
  if (key == "texImage2D") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLenum target = static_cast<GLenum>(args[0].ToNumber());
          GLint level = static_cast<GLint>(args[1].ToNumber());
          GLint internalFormat = static_cast<GLint>(args[2].ToNumber());
          GLsizei width = static_cast<GLsizei>(args[3].ToNumber());
          GLsizei height = static_cast<GLsizei>(args[4].ToNumber());
          GLint border = static_cast<GLint>(args[5].ToNumber());
          GLenum format = static_cast<GLenum>(args[6].ToNumber());
          GLenum type = static_cast<GLenum>(args[7].ToNumber());
          void *data = nullptr;
          if (args[8].IsBytes()) {
            data = args[8].ToBytes().begin();
          }
          using f = void(*)(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const void*);
          reinterpret_cast<f>(glTexImage2D_)(
              target, level, internalFormat, width, height, border, format, type, data);
          return Value{};
        })};
  }
  if (key == "texParameteri") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLenum target = static_cast<GLenum>(args[0].ToNumber());
          GLenum pname = static_cast<GLenum>(args[1].ToNumber());
          GLint param = static_cast<GLint>(args[2].ToNumber());
          using f = void(*)(GLenum, GLenum, GLint);
          reinterpret_cast<f>(glTexParameteri_)(target, pname, param);
          return Value{};
        })};
  }
  if (key == "texSubImage2D") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLenum target = static_cast<GLenum>(args[0].ToNumber());
          GLint level = static_cast<GLint>(args[1].ToNumber());
          GLint xoffset = static_cast<GLint>(args[2].ToNumber());
          GLint yoffset = static_cast<GLint>(args[3].ToNumber());
          GLsizei width = static_cast<GLsizei>(args[4].ToNumber());
          GLsizei height = static_cast<GLsizei>(args[5].ToNumber());
          GLenum format = static_cast<GLenum>(args[6].ToNumber());
          GLenum type = static_cast<GLenum>(args[7].ToNumber());
          void *data = nullptr;
          if (!args[8].IsNull()) {
            data = args[8].ToBytes().begin();
          }
          using f = void(*)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const void*);
          reinterpret_cast<f>(glTexSubImage2D_)(
              target, level, xoffset, yoffset, width, height, format, type, data);
          return Value{};
        })};
  }
  if (key == "uniform1f") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLint location = static_cast<GLint>(args[0].ToNumber());
          GLfloat v0 = static_cast<GLfloat>(args[1].ToNumber());
          using f = void(*)(GLint, GLfloat);
          reinterpret_cast<f>(glUniform1f_)(location, v0);
          return Value{};
        })};
  }
  if (key == "uniform1fv") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLint location = static_cast<GLint>(args[0].ToNumber());
          BytesSpan bytes = args[1].ToBytes();
          GLsizei count = bytes.size() / sizeof(GLfloat);
          GLfloat *value = reinterpret_cast<GLfloat *>(bytes.begin());
          using f = void(*)(GLint, GLsizei, GLfloat*);
          reinterpret_cast<f>(glUniform1fv_)(location, count, value);
          return Value{};
        })};
  }
  if (key == "uniform1i") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLint location = static_cast<GLint>(args[0].ToNumber());
          GLint v0 = static_cast<GLint>(args[1].ToNumber());
          using f = void(*)(GLint, GLint);
          reinterpret_cast<f>(glUniform1i_)(location, v0);
          return Value{};
        })};
  }
  if (key == "uniform2fv") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLint location = static_cast<GLint>(args[0].ToNumber());
          BytesSpan bytes = args[1].ToBytes();
          GLsizei count = bytes.size() / sizeof(GLfloat) / 2;
          GLfloat *value = reinterpret_cast<GLfloat *>(bytes.begin());
          using f = void(*)(GLint, GLsizei, GLfloat*);
          reinterpret_cast<f>(glUniform2fv_)(location, count, value);
          return Value{};
        })};
  }
  if (key == "uniform3fv") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLint location = static_cast<GLint>(args[0].ToNumber());
          BytesSpan bytes = args[1].ToBytes();
          GLsizei count = bytes.size() / sizeof(GLfloat) / 3;
          GLfloat *value = reinterpret_cast<GLfloat *>(bytes.begin());
          using f = void(*)(GLint, GLsizei, GLfloat*);
          reinterpret_cast<f>(glUniform3fv_)(location, count, value);
          return Value{};
        })};
  }
  if (key == "uniform4fv") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLint location = static_cast<GLint>(args[0].ToNumber());
          BytesSpan bytes = args[1].ToBytes();
          GLsizei count = bytes.size() / sizeof(GLfloat) / 4;
          GLfloat *value = reinterpret_cast<GLfloat *>(bytes.begin());
          using f = void(*)(GLint, GLsizei, GLfloat*);
          reinterpret_cast<f>(glUniform4fv_)(location, count, value);
          return Value{};
        })};
  }
  if (key == "uniformMatrix2fv") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLint location = static_cast<GLint>(args[0].ToNumber());
          GLboolean transpose = static_cast<GLboolean>(args[0].ToBool());
          BytesSpan bytes = args[2].ToBytes();
          GLsizei count = bytes.size() / sizeof(GLfloat) / 4;
          GLfloat *value = reinterpret_cast<GLfloat *>(bytes.begin());
          using f = void(*)(GLint, GLsizei, GLboolean, GLfloat*);
          reinterpret_cast<f>(glUniformMatrix2fv_)(location, count, transpose, value);
          return Value{};
        })};
  }
  if (key == "uniformMatrix3fv") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLint location = static_cast<GLint>(args[0].ToNumber());
          GLboolean transpose = static_cast<GLboolean>(args[0].ToBool());
          BytesSpan bytes = args[2].ToBytes();
          GLsizei count = bytes.size() / sizeof(GLfloat) / 9;
          GLfloat *value = reinterpret_cast<GLfloat *>(bytes.begin());
          using f = void(*)(GLint, GLsizei, GLboolean, GLfloat*);
          reinterpret_cast<f>(glUniformMatrix3fv_)(location, count, transpose, value);
          return Value{};
        })};
  }
  if (key == "uniformMatrix4fv") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLint location = static_cast<GLint>(args[0].ToNumber());
          GLboolean transpose = static_cast<GLboolean>(args[0].ToBool());
          BytesSpan bytes = args[2].ToBytes();
          GLsizei count = bytes.size() / sizeof(GLfloat) / 16;
          GLfloat *value = reinterpret_cast<GLfloat *>(bytes.begin());
          using f = void(*)(GLint, GLsizei, GLboolean, GLfloat*);
          reinterpret_cast<f>(glUniformMatrix4fv_)(location, count, transpose, value);
          return Value{};
        })};
  }
  if (key == "useProgram") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint program = static_cast<GLuint>(args[0].ToNumber());
          using f = void(*)(GLuint);
          reinterpret_cast<f>(glUseProgram_)(program);
          return Value{};
        })};
  }
  if (key == "vertexAttribPointer") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLuint index = static_cast<GLuint>(args[0].ToNumber());
          GLint size = static_cast<GLint>(args[1].ToNumber());
          GLenum type = static_cast<GLenum>(args[2].ToNumber());
          GLboolean normalized = static_cast<GLboolean>(args[3].ToBool());
          GLsizei stride = static_cast<GLsizei>(args[4].ToNumber());
          void *pointer = nullptr;
          if (args[5].IsNumber()) {
            pointer = reinterpret_cast<void *>(
                static_cast<uintptr_t>(args[5].ToNumber()));
          }
          if (args[5].IsBytes()) {
            pointer = args[5].ToBytes().begin();
          }
          using f = void(*)(GLuint, GLint, GLenum, GLboolean, GLsizei, const void*);
          reinterpret_cast<f>(glVertexAttribPointer_)(
              index, size, type, normalized, stride, pointer);
          return Value{};
        })};
  }
  if (key == "viewport") {
    return Value{std::make_shared<FuncObject>(
        [this](Value self, std::vector<Value> args) -> Value {
          GLint x = static_cast<GLint>(args[0].ToNumber());
          GLint y = static_cast<GLint>(args[1].ToNumber());
          GLsizei width = static_cast<GLsizei>(args[2].ToNumber());
          GLsizei height = static_cast<GLsizei>(args[3].ToNumber());
          using f = void(*)(GLint, GLint, GLsizei, GLsizei);
          reinterpret_cast<f>(glViewport_)(x, y, width, height);
          return Value{};
        })};
  }
  fprintf(stderr, "%s is not implemented\n", key.c_str());
  return Value{};
}

std::string GL::ToString() const {
  return "GL";
}

}
`))
