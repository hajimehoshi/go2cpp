// SPDX-License-Identifier: Apache-2.0

package gowasm2cpp

import (
	"os"
	"path/filepath"
	"text/template"
)

func writeGame(dir string, incpath string, namespace string) error {
	{
		f, err := os.Create(filepath.Join(dir, "game.h"))
		if err != nil {
			return err
		}
		defer f.Close()

		if err := gameHTmpl.Execute(f, struct {
			IncludeGuard string
			IncludePath  string
			Namespace    string
		}{
			IncludeGuard: includeGuard(namespace) + "_GAME_H",
			IncludePath:  incpath,
			Namespace:    namespace,
		}); err != nil {
			return err
		}
	}
	{
		f, err := os.Create(filepath.Join(dir, "game.cpp"))
		if err != nil {
			return err
		}
		defer f.Close()

		if err := gameCppTmpl.Execute(f, struct {
			IncludePath string
			Namespace   string
		}{
			IncludePath: incpath,
			Namespace:   namespace,
		}); err != nil {
			return err
		}
	}
	return nil
}

var gameHTmpl = template.Must(template.New("game.h").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#ifndef {{.IncludeGuard}}
#define {{.IncludeGuard}}

#include "{{.IncludePath}}go.h"

#include <cstdint>
#include <functional>
#include <memory>
#include <vector>

namespace {{.Namespace}} {

class Game {
public:
  struct Touch {
    int id;
    int x;
    int y;
  };

  struct Gamepad {
    int id;
    int button_count;
    bool buttons[256];
    int axis_count;
    float axes[16];
  };

  class Driver {
  public:
    virtual ~Driver();
    virtual bool Init() = 0;
    virtual void Update(std::function<void()> f) = 0;
    virtual int GetScreenWidth() = 0;
    virtual int GetScreenHeight() = 0;
    virtual double GetDevicePixelRatio() = 0;
    virtual void* GetOpenGLFunction(const char* name) = 0;
    virtual std::vector<Touch> GetTouches() = 0;
    virtual std::vector<Gamepad> GetGamepads() = 0;

    virtual void OpenAudio(int sample_rate, int channel_num, int bit_depth_in_bytes, int buffer_size) = 0;
    virtual int CreateAudioPlayer() = 0;
    virtual double AudioPlayerGetVolume(int player_id) = 0;
    virtual void AudioPlayerSetVolume(int player_id, double volume) = 0;
    virtual void AudioPlayerPause(int player_id) = 0;
    virtual void AudioPlayerPlay(int player_id) = 0;
    virtual void AudioPlayerClose(int player_id) = 0;
    virtual void AudioPlayerWrite(int player_id, const uint8_t* data, int length) = 0;
    virtual bool AudioPlayerIsWritable(int player_id) = 0;
  };

  class Binding {
  public:
    virtual ~Binding();
    virtual std::vector<uint8_t> Get(const std::string& key) = 0;
    virtual void Set(const std::string& key, const uint8_t* data, int length) = 0;
  };

  explicit Game(std::unique_ptr<Driver> driver);
  Game(std::unique_ptr<Driver> driver, std::unique_ptr<Binding> binding);

  int Run();

private:
  void Update(Value f);

  std::unique_ptr<Driver> driver_;
  std::vector<Touch> touches_;
  std::vector<Gamepad> gamepads_;
  std::unique_ptr<Binding> binding_;
};

}

#endif  // {{.IncludeGuard}}
`))

var gameCppTmpl = template.Must(template.New("game.cpp").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#include "{{.IncludePath}}game.h"

#include "{{.IncludePath}}gl.h"

#include <cstring>
#include <thread>

namespace {{.Namespace}} {

namespace {

class BindingObject : public Object {
public:
  explicit BindingObject(Game::Binding* binding)
      : binding_{binding} {
  }

  Value Get(const std::string& key) override {
    auto bytes = binding_->Get(key);
    auto u8 = std::make_shared<Uint8Array>(bytes.size());
    std::memcpy(u8->ToBytes().begin(), &(*bytes.begin()), bytes.size());
    return Value{u8};
  }

  void Set(const std::string& key, Value value) override {
    auto bytes = value.ToBytes();
    binding_->Set(key, &(*bytes.begin()), bytes.size());
  }

  std::string ToString() const override {
    return "BindingObject";
  }

private:
  Game::Binding* binding_;
};

class AudioPlayer : public Object {
public:
  AudioPlayer(Game::Driver* driver, Value on_written)
      : driver_{driver},
        on_written_{on_written} {
    player_id_ = driver->CreateAudioPlayer();
  }

  ~AudioPlayer() override {
    Close();
  }

  Value Get(const std::string& key) override {
    if (key == "volume") {
      return Value{driver_->AudioPlayerGetVolume(player_id_)};
    }
    if (key == "pause") {
      return Value{std::make_shared<Function>(
        [this](Value self, std::vector<Value> args) -> Value {
          driver_->AudioPlayerPause(player_id_);
          return Value{};
        })};
    }
    if (key == "play") {
      return Value{std::make_shared<Function>(
        [this](Value self, std::vector<Value> args) -> Value {
          driver_->AudioPlayerPlay(player_id_);
          return Value{};
        })};
    }
    if (key == "close") {
      return Value{std::make_shared<Function>(
        [this](Value self, std::vector<Value> args) -> Value {
          Close();
          return Value{};
        })};
    }
    if (key == "write") {
      return Value{std::make_shared<Function>(
        [this](Value self, std::vector<Value> args) -> Value {
          BytesSpan buf = args[0].ToBytes();
          int size = static_cast<int>(args[1].ToNumber());
          driver_->AudioPlayerWrite(player_id_, buf.begin(), size);
          on_written_.ToObject().Invoke({}, {});
          return Value{};
        })};
    }
    if (key == "isWritable") {
      return Value{std::make_shared<Function>(
        [this](Value self, std::vector<Value> args) -> Value {
          return Value{driver_->AudioPlayerIsWritable(player_id_)};
        })};
    }
    return Value{};
  }

  void Set(const std::string& key, Value value) override {
    if (key == "volume") {
      driver_->AudioPlayerSetVolume(player_id_, value.ToNumber());
      return;
    }
  }

  std::string ToString() const override {
    return "AudioPlayer";
  }

private:
  void Close() {
    driver_->AudioPlayerClose(player_id_);
  }

  Game::Driver* driver_;
  int player_id_;
  Value buf_;
  Value on_written_;
};

class Audio : public Object {
public:
  explicit Audio(Game::Driver* driver)
      : driver_{driver} {
  }

  Value Get(const std::string& key) override {
    if (key == "createPlayer") {
      return Value{std::make_shared<Function>(
        [this](Value self, std::vector<Value> args) -> Value {
          return Value{std::make_shared<AudioPlayer>(driver_, args[0])};
        })};
    }
    return Value{};
  }

  std::string ToString() const override {
    return "Audio";
  }

private:
  Game::Driver* driver_;
};

} // namespace

Game::Driver::~Driver() = default;

Game::Game(std::unique_ptr<Driver> driver)
  : Game(std::move(driver), nullptr) {
}

Game::Game(std::unique_ptr<Driver> driver, std::unique_ptr<Binding> binding)
  : driver_{std::move(driver)},
    binding_{std::move(binding)} {
}

int Game::Run() {
  if (!driver_->Init()) {
    return EXIT_FAILURE;
  }

  auto& global = Value::Global().ToObject();
  auto go2cpp = std::make_shared<DictionaryValues>();
  global.Set("go2cpp", Value{go2cpp});

  auto gl = std::make_shared<GL>([this](const char* name) -> void* {
    return driver_->GetOpenGLFunction(name);
  });
  go2cpp->Set("gl", Value{gl});

  go2cpp->Set("screenWidth",
      Value{static_cast<double>(driver_->GetScreenWidth())});
  go2cpp->Set("screenHeight",
      Value{static_cast<double>(driver_->GetScreenHeight())});
  go2cpp->Set("devicePixelRatio", Value{driver_->GetDevicePixelRatio()});

  go2cpp->Set("touchCount", Value{0.0});
  go2cpp->Set("getTouchId", Value{std::make_shared<Function>(
    [this](Value self, std::vector<Value> args) -> Value {
      int idx = static_cast<int>(args[0].ToNumber());
      return Value{static_cast<double>(touches_[idx].id)};
    })});
  go2cpp->Set("getTouchX", Value{std::make_shared<Function>(
    [this](Value self, std::vector<Value> args) -> Value {
      int idx = static_cast<int>(args[0].ToNumber());
      return Value{static_cast<double>(touches_[idx].x)};
    })});
  go2cpp->Set("getTouchY", Value{std::make_shared<Function>(
    [this](Value self, std::vector<Value> args) -> Value {
      int idx = static_cast<int>(args[0].ToNumber());
      return Value{static_cast<double>(touches_[idx].y)};
    })});

  go2cpp->Set("gamepadCount", Value{0.0});
  go2cpp->Set("getGamepadId", Value{std::make_shared<Function>(
    [this](Value self, std::vector<Value> args) -> Value {
      int idx = static_cast<int>(args[0].ToNumber());
      return Value{static_cast<double>(gamepads_[idx].id)};
    })});
  go2cpp->Set("getGamepadButtonCount", Value{std::make_shared<Function>(
    [this](Value self, std::vector<Value> args) -> Value {
      int idx = static_cast<int>(args[0].ToNumber());
      return Value{static_cast<double>(gamepads_[idx].button_count)};
    })});
  go2cpp->Set("isGamepadButtonPressed", Value{std::make_shared<Function>(
    [this](Value self, std::vector<Value> args) -> Value {
      int idx = static_cast<int>(args[0].ToNumber());
      int button_idx = static_cast<int>(args[1].ToNumber());
      return Value{gamepads_[idx].buttons[button_idx]};
    })});
  go2cpp->Set("getGamepadAxisCount", Value{std::make_shared<Function>(
    [this](Value self, std::vector<Value> args) -> Value {
      int idx = static_cast<int>(args[0].ToNumber());
      return Value{static_cast<double>(gamepads_[idx].axis_count)};
    })});
  go2cpp->Set("getGamepadAxis", Value{std::make_shared<Function>(
    [this](Value self, std::vector<Value> args) -> Value {
      int idx = static_cast<int>(args[0].ToNumber());
      int axis_idx = static_cast<int>(args[1].ToNumber());
      return Value{static_cast<double>(gamepads_[idx].axes[axis_idx])};
    })});

  Go go;

  go2cpp->Set("createAudio", Value{std::make_shared<Function>(
    [this](Value self, std::vector<Value> args) -> Value {
      int sample_rate = static_cast<int>(args[0].ToNumber());
      int channel_num = static_cast<int>(args[1].ToNumber());
      int bit_depth_in_bytes = static_cast<int>(args[2].ToNumber());
      int buffer_size = static_cast<int>(args[3].ToNumber());

      driver_->OpenAudio(sample_rate, channel_num, bit_depth_in_bytes, buffer_size);
      return Value{std::make_shared<Audio>(driver_.get())};
    })});

  if (binding_) {
    go2cpp->Set("binding", Value{std::make_shared<BindingObject>(binding_.get())});
  }

  global.Set("requestAnimationFrame",
             Value{std::make_shared<Function>(
                 [this, &go](Value self, std::vector<Value> args) -> Value {
                   Value f = args[0];
                   go.EnqueueTask([this, f]() {
                     driver_->Update([this, f]() mutable {
                       Update(f);
                     });
                   });
                   return Value{};
                 })});

  return go.Run();
}

void Game::Update(Value f) {
  auto& global = Value::Global().ToObject();
  auto& go2cpp = global.Get("go2cpp").ToObject();

  touches_ = driver_->GetTouches();
  go2cpp.Set("touchCount", Value{static_cast<double>(touches_.size())});

  gamepads_ = driver_->GetGamepads();
  go2cpp.Set("gamepadCount", Value{static_cast<double>(gamepads_.size())});

  f.ToObject().Invoke(Value{}, {});
}

Game::Binding::~Binding() = default;

}
`))
