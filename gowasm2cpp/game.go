// SPDX-License-Identifier: Apache-2.0

package gowasm2cpp

import (
	"os"
	"path/filepath"
	"text/template"
)

func writeGame(dir string, incpath string, namespace string) error {
	{
		f, err := os.Create(filepath.Join(dir, "game.h"))
		if err != nil {
			return err
		}
		defer f.Close()

		if err := gameHTmpl.Execute(f, struct {
			IncludeGuard string
			IncludePath  string
			Namespace    string
		}{
			IncludeGuard: includeGuard(namespace) + "_GAME_H",
			IncludePath:  incpath,
			Namespace:    namespace,
		}); err != nil {
			return err
		}
	}
	{
		f, err := os.Create(filepath.Join(dir, "game.cpp"))
		if err != nil {
			return err
		}
		defer f.Close()

		if err := gameCppTmpl.Execute(f, struct {
			IncludePath string
			Namespace   string
		}{
			IncludePath: incpath,
			Namespace:   namespace,
		}); err != nil {
			return err
		}
	}
	return nil
}

var gameHTmpl = template.Must(template.New("game.h").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#ifndef {{.IncludeGuard}}
#define {{.IncludeGuard}}

#include "{{.IncludePath}}go.h"

#include <cstdint>
#include <functional>
#include <memory>
#include <vector>

namespace {{.Namespace}} {

class Game {
public:
  struct Touch {
    int id;
    int x;
    int y;
  };

  struct Gamepad {
    int id;
    int button_count;
    bool buttons[256];
    int axis_count;
    float axes[16];
  };

  class Driver {
  public:
    virtual ~Driver();
    virtual bool Init() = 0;
    virtual void Update(std::function<void()> f) = 0;
    virtual int GetScreenWidth() = 0;
    virtual int GetScreenHeight() = 0;
    virtual double GetDevicePixelRatio() = 0;
    virtual void* GetOpenGLFunction(const char* name) = 0;
    virtual std::vector<Touch> GetTouches() = 0;
    virtual std::vector<Gamepad> GetGamepads() = 0;

    virtual void OpenAudio(int sample_rate, int channel_num, int bit_depth_in_bytes, int buffer_size) = 0;

    // SendDataToAudio returns the number of the written bytes.
    // SendDataToAudio can return 0 only when the given buffer is not enough.
    // SendDataToAudio is called from a differen thread than the main thread.
    virtual int SendDataToAudio(const uint8_t* data, int length) = 0;
  };

  class Binding {
  public:
    virtual ~Binding();
    virtual std::vector<uint8_t> Get(const std::string& key) = 0;
    virtual void Set(const std::string& key, const uint8_t* data, int length) = 0;
  };

  explicit Game(std::unique_ptr<Driver> driver);
  Game(std::unique_ptr<Driver> driver, std::unique_ptr<Binding> binding);

  int Run();

private:
  void Update(Value f);

  std::unique_ptr<Driver> driver_;
  std::vector<Touch> touches_;
  std::vector<Gamepad> gamepads_;
  std::unique_ptr<Binding> binding_;
};

}

#endif  // {{.IncludeGuard}}
`))

var gameCppTmpl = template.Must(template.New("game.cpp").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#include "{{.IncludePath}}game.h"

#include "{{.IncludePath}}gl.h"

#include <thread>

namespace {{.Namespace}} {

namespace {

class BindingObject : public Object {
public:
  explicit BindingObject(Game::Binding* binding)
      : binding_{binding} {
  }

  Value Get(const std::string& key) override {
    auto bytes = binding_->Get(key);
    auto u8 = std::make_shared<Uint8Array>(bytes.size());
    std::memcpy(u8->ToBytes().begin(), &(*bytes.begin()), bytes.size());
    return Value{u8};
  }

  void Set(const std::string& key, Value value) override {
    auto bytes = value.ToBytes();
    binding_->Set(key, &(*bytes.begin()), bytes.size());
  }

  std::string ToString() const override {
    return "BindingObject";
  }

private:
  Game::Binding* binding_;
};

class Audio : public Object {
public:
  Audio(Go* go, Game::Driver* driver, int buffer_size)
    : go_{go},
      driver_{driver},
      buffer_size_{buffer_size},
      thread_{[this]() { Loop(); }} {
  }

  Value Get(const std::string& key) override {
    if (key == "sendDataToBuffer") {
      return Value{std::make_shared<Function>(
        [this](Value self, std::vector<Value> args) -> Value {
          BytesSpan buf = args[0].ToBytes();
          int len = static_cast<int>(args[1].ToNumber());
          int n = SendDataToLoopThread(BytesSpan(buf.begin(), len));
          return Value{static_cast<double>(n)};
        })};
    }
    return Value{};
  }

  void Set(const std::string& key, Value value) override {
    if (key == "onBufferConsumed") {
      on_buffer_consumed_ = value;
    }
  }

  std::string ToString() const override {
    return "Audio";
  }

private:
  int SendDataToLoopThread(BytesSpan buf) {
    int n = 0;
    {
      std::lock_guard<std::mutex> lock{mutex_};

      if (current_buf_.capacity() < buffer_size_) {
        current_buf_.reserve(buffer_size_);
      }

      if (current_buf_.size() < buffer_size_) {
        n = buf.size();
        if (n > buffer_size_ - current_buf_.size()) {
          n = buffer_size_ - current_buf_.size();
        }
        current_buf_.insert(current_buf_.end(), buf.begin(), buf.begin() + n);
      }
    }
    cond_.notify_one();
    return n;
  }

  void Loop() {
    int require = 0;

    for (;;) {
      std::vector<uint8_t> buf;
      int n = 0;
      {
        std::unique_lock<std::mutex> lock{mutex_};
        cond_.wait(lock, [this, require]{ return current_buf_.size() > require; });
        buf = current_buf_;
        lock.unlock();

        n = driver_->SendDataToAudio(&(*buf.begin()), buf.size());
        // The given data is not enough. Wait for new inputs again.
        if (!n) {
          require = buf.size();
          continue;
        }
        require = 0;

        lock.lock();
        // TODO: This is not efficient. Replace this with a deque?
        current_buf_.erase(current_buf_.begin(), current_buf_.begin() + n);
      }

      go_->EnqueueTask([this, n]() {
        on_buffer_consumed_.ToObject().Invoke(Value{}, {Value{static_cast<double>(n)}});
      });
    }
  }

  Go* go_;
  Game::Driver* driver_;
  int buffer_size_;
  Value on_buffer_consumed_;
  std::vector<uint8_t> current_buf_;

  std::mutex mutex_;
  std::condition_variable cond_;

  std::thread thread_;
};

} // namespace

Game::Driver::~Driver() = default;

Game::Game(std::unique_ptr<Driver> driver)
  : Game(std::move(driver), nullptr) {
}

Game::Game(std::unique_ptr<Driver> driver, std::unique_ptr<Binding> binding)
  : driver_{std::move(driver)},
    binding_{std::move(binding)} {
}

int Game::Run() {
  if (!driver_->Init()) {
    return EXIT_FAILURE;
  }

  auto& global = Value::Global().ToObject();
  auto go2cpp = std::make_shared<DictionaryValues>();
  global.Set("go2cpp", Value{go2cpp});

  auto gl = std::make_shared<GL>([this](const char* name) -> void* {
    return driver_->GetOpenGLFunction(name);
  });
  go2cpp->Set("gl", Value{gl});

  go2cpp->Set("screenWidth",
      Value{static_cast<double>(driver_->GetScreenWidth())});
  go2cpp->Set("screenHeight",
      Value{static_cast<double>(driver_->GetScreenHeight())});
  go2cpp->Set("devicePixelRatio", Value{driver_->GetDevicePixelRatio()});

  go2cpp->Set("touchCount", Value{0.0});
  go2cpp->Set("getTouchId", Value{std::make_shared<Function>(
    [this](Value self, std::vector<Value> args) -> Value {
      int idx = static_cast<int>(args[0].ToNumber());
      return Value{static_cast<double>(touches_[idx].id)};
    })});
  go2cpp->Set("getTouchX", Value{std::make_shared<Function>(
    [this](Value self, std::vector<Value> args) -> Value {
      int idx = static_cast<int>(args[0].ToNumber());
      return Value{static_cast<double>(touches_[idx].x)};
    })});
  go2cpp->Set("getTouchY", Value{std::make_shared<Function>(
    [this](Value self, std::vector<Value> args) -> Value {
      int idx = static_cast<int>(args[0].ToNumber());
      return Value{static_cast<double>(touches_[idx].y)};
    })});

  go2cpp->Set("gamepadCount", Value{0.0});
  go2cpp->Set("getGamepadId", Value{std::make_shared<Function>(
    [this](Value self, std::vector<Value> args) -> Value {
      int idx = static_cast<int>(args[0].ToNumber());
      return Value{static_cast<double>(gamepads_[idx].id)};
    })});
  go2cpp->Set("getGamepadButtonCount", Value{std::make_shared<Function>(
    [this](Value self, std::vector<Value> args) -> Value {
      int idx = static_cast<int>(args[0].ToNumber());
      return Value{static_cast<double>(gamepads_[idx].button_count)};
    })});
  go2cpp->Set("isGamepadButtonPressed", Value{std::make_shared<Function>(
    [this](Value self, std::vector<Value> args) -> Value {
      int idx = static_cast<int>(args[0].ToNumber());
      int button_idx = static_cast<int>(args[1].ToNumber());
      return Value{gamepads_[idx].buttons[button_idx]};
    })});
  go2cpp->Set("getGamepadAxisCount", Value{std::make_shared<Function>(
    [this](Value self, std::vector<Value> args) -> Value {
      int idx = static_cast<int>(args[0].ToNumber());
      return Value{static_cast<double>(gamepads_[idx].axis_count)};
    })});
  go2cpp->Set("getGamepadAxis", Value{std::make_shared<Function>(
    [this](Value self, std::vector<Value> args) -> Value {
      int idx = static_cast<int>(args[0].ToNumber());
      int axis_idx = static_cast<int>(args[1].ToNumber());
      return Value{static_cast<double>(gamepads_[idx].axes[axis_idx])};
    })});

  Go go;

  go2cpp->Set("createAudio", Value{std::make_shared<Function>(
    [this, &go](Value self, std::vector<Value> args) -> Value {
      int sample_rate = static_cast<int>(args[0].ToNumber());
      int channel_num = static_cast<int>(args[1].ToNumber());
      int bit_depth_in_bytes = static_cast<int>(args[2].ToNumber());
      int buffer_size = static_cast<int>(args[3].ToNumber());

      driver_->OpenAudio(sample_rate, channel_num, bit_depth_in_bytes, buffer_size);
      return Value{std::make_shared<Audio>(&go, driver_.get(), buffer_size)};
    })});

  if (binding_) {
    go2cpp->Set("binding", Value{std::make_shared<BindingObject>(binding_.get())});
  }

  global.Set("requestAnimationFrame",
             Value{std::make_shared<Function>(
                 [this, &go](Value self, std::vector<Value> args) -> Value {
                   Value f = args[0];
                   go.EnqueueTask([this, f]() {
                     driver_->Update([this, f]() mutable {
                       Update(f);
                     });
                   });
                   return Value{};
                 })});

  return go.Run();
}

void Game::Update(Value f) {
  auto& global = Value::Global().ToObject();
  auto& go2cpp = global.Get("go2cpp").ToObject();

  touches_ = driver_->GetTouches();
  go2cpp.Set("touchCount", Value{static_cast<double>(touches_.size())});

  gamepads_ = driver_->GetGamepads();
  go2cpp.Set("gamepadCount", Value{static_cast<double>(gamepads_.size())});

  f.ToObject().Invoke(Value{}, {});
}

Game::Binding::~Binding() = default;

}
`))
