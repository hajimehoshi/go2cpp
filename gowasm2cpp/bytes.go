// SPDX-License-Identifier: Apache-2.0

package gowasm2cpp

import (
	"os"
	"path/filepath"
	"text/template"
)

func writeBytes(dir string, incpath string, namespace string) error {
	{
		f, err := os.Create(filepath.Join(dir, "bytes.h"))
		if err != nil {
			return err
		}
		defer f.Close()

		if err := bytesHTmpl.Execute(f, struct {
			IncludeGuard string
			IncludePath  string
			Namespace    string
		}{
			IncludeGuard: includeGuard(namespace) + "_BYTES_H",
			IncludePath:  incpath,
			Namespace:    namespace,
		}); err != nil {
			return err
		}
	}
	{
		f, err := os.Create(filepath.Join(dir, "bytes.cpp"))
		if err != nil {
			return err
		}
		defer f.Close()

		if err := bytesCppTmpl.Execute(f, struct {
			IncludePath string
			Namespace   string
		}{
			IncludePath: incpath,
			Namespace:   namespace,
		}); err != nil {
			return err
		}
	}
	return nil
}

var bytesHTmpl = template.Must(template.New("bytes.h").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#ifndef {{.IncludeGuard}}
#define {{.IncludeGuard}}

#include <cstdint>
#include <vector>

namespace {{.Namespace}} {

// TODO: Replace this with std::span in the C++20 era.
class BytesSpan {
public:
  BytesSpan();
  BytesSpan(uint8_t* data, size_t size);
  BytesSpan(const BytesSpan& span);
  BytesSpan& operator=(BytesSpan& span);

  uint8_t* begin();
  uint8_t* end();
  size_t size() const;

  bool IsNull() const;

private:
  uint8_t* data_ = nullptr;
  size_t size_ = 0;
};

class BytesSegment {
public:
  using size_type = std::vector<uint8_t>::size_type;
  using reference = std::vector<uint8_t>::reference;
  using const_reference = std::vector<uint8_t>::const_reference;
  using iterator = std::vector<uint8_t>::iterator;
  using const_iterator = std::vector<uint8_t>::const_iterator;

  BytesSegment(std::vector<uint8_t>& bytes, size_type offset, size_type length);

  reference operator[](size_type n);
  const_reference operator[](size_type n) const;
  size_type size() const;
  iterator begin();
  const_iterator begin() const;
  iterator end();
  const_iterator end() const;

private:
  std::vector<uint8_t>& bytes_;
  const size_type offset_ = 0;
  const size_type length_ = 0;
};

}

#endif  // {{.IncludeGuard}}
`))

var bytesCppTmpl = template.Must(template.New("bytes.cpp").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#include "{{.IncludePath}}bytes.h"

namespace {{.Namespace}} {

BytesSpan::BytesSpan() = default;

BytesSpan::BytesSpan(uint8_t* data, size_t size)
    : data_(data),
      size_(size) {
}

BytesSpan::BytesSpan(const BytesSpan& span) = default;

BytesSpan& BytesSpan::operator=(BytesSpan& span) = default;

uint8_t* BytesSpan::begin() {
  return data_;
}

uint8_t* BytesSpan::end() {
  return data_ + size_;
}

size_t BytesSpan::size() const {
  return size_;
}

bool BytesSpan::IsNull() const {
  return !data_;
}

BytesSegment::BytesSegment(std::vector<uint8_t>& bytes, size_type offset, size_type length)
    : bytes_{bytes},
      offset_{offset},
      length_{length} {
}

BytesSegment::reference BytesSegment::operator[](size_type n) {
  return bytes_[n + offset_];
}

BytesSegment::const_reference BytesSegment::operator[](size_type n) const {
  return bytes_[n + offset_];
}

BytesSegment::size_type BytesSegment::size() const {
  return length_;
}

BytesSegment::iterator BytesSegment::begin() {
  return bytes_.begin() + offset_;
}

BytesSegment::const_iterator BytesSegment::begin() const {
  return bytes_.begin() + offset_;
}

BytesSegment::iterator BytesSegment::end() {
  return bytes_.begin() + offset_ + length_;
}

BytesSegment::const_iterator BytesSegment::end() const {
  return bytes_.begin() + offset_ + length_;
}

}
`))
