// SPDX-License-Identifier: Apache-2.0

package gowasm2cpp

import (
	"os"
	"path/filepath"
	"text/template"
)

func writeBits(dir string, incpath string, namespace string) error {
	{
		f, err := os.Create(filepath.Join(dir, "bits.h"))
		if err != nil {
			return err
		}
		defer f.Close()

		if err := bitsHTmpl.Execute(f, struct {
			IncludeGuard string
			IncludePath  string
			Namespace    string
		}{
			IncludeGuard: includeGuard(namespace) + "_BITS_H",
			IncludePath:  incpath,
			Namespace:    namespace,
		}); err != nil {
			return err
		}
	}
	{
		f, err := os.Create(filepath.Join(dir, "bits.cpp"))
		if err != nil {
			return err
		}
		defer f.Close()

		if err := bitsCppTmpl.Execute(f, struct {
			IncludePath string
			Namespace   string
		}{
			IncludePath: incpath,
			Namespace:   namespace,
		}); err != nil {
			return err
		}
	}
	return nil
}

var bitsHTmpl = template.Must(template.New("bits.h").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#ifndef {{.IncludeGuard}}
#define {{.IncludeGuard}}

#include <cmath>
#include <cstdint>

namespace {{.Namespace}} {

class Bits {
public:
  static uint32_t RotateLeft(uint32_t x, int32_t k);
  static uint64_t RotateLeft(uint64_t x, int32_t k);
};

class Math {
public:
  static float Round(float x);
  static double Round(double x);
};

}

#endif  // {{.IncludeGuard}}
`))

var bitsCppTmpl = template.Must(template.New("bits.cpp").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#include "{{.IncludePath}}bits.h"

namespace {{.Namespace}} {

// The implementation is copied from the Go standard package math/bits, which is under BSD-style license.

uint32_t Bits::RotateLeft(uint32_t x, int32_t k) {
  constexpr int32_t n = 32;
  int32_t s = k & (n - 1);
  return x<<s | x>>(n-s);
}

uint64_t Bits::RotateLeft(uint64_t x, int32_t k) {
  constexpr int32_t n = 64;
  int32_t s = k & (n - 1);
  return x<<s | x>>(n-s);
}

float Math::Round(float x) {
  // std::rint is also available, but this requires setting a global state by std::fesetround.
  float r = std::round(x);
  if (std::abs(x - r) == 0.5f && std::fmod(r, 2.0f) != 0.0f) {
    return std::trunc(x);
  }
  return r;
}

double Math::Round(double x) {
  double r = std::round(x);
  if (std::abs(x - r) == 0.5 && std::fmod(r, 2.0) != 0.0) {
    return std::trunc(x);
  }
  return r;
}

}
`))
