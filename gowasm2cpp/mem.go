// SPDX-License-Identifier: Apache-2.0

package gowasm2cpp

import (
	"os"
	"path/filepath"
	"text/template"
)

type wasmData struct {
	Offset int
	Data   []byte
}

func writeMem(dir string, incpath string, namespace string, initPageNum int, data []wasmData) error {
	{
		f, err := os.Create(filepath.Join(dir, "mem.h"))
		if err != nil {
			return err
		}
		defer f.Close()

		if err := memHTmpl.Execute(f, struct {
			IncludeGuard string
			IncludePath  string
			Namespace    string
		}{
			IncludeGuard: includeGuard(namespace) + "_MEM_H",
			IncludePath:  incpath,
			Namespace:    namespace,
		}); err != nil {
			return err
		}
	}
	{
		f, err := os.Create(filepath.Join(dir, "mem.cpp"))
		if err != nil {
			return err
		}
		defer f.Close()

		if err := memCppTmpl.Execute(f, struct {
			IncludePath string
			Namespace   string
			InitPageNum int
			Data        []wasmData
		}{
			IncludePath: incpath,
			Namespace:   namespace,
			InitPageNum: initPageNum,
			Data:        data,
		}); err != nil {
			return err
		}
	}
	return nil
}

var memHTmpl = template.Must(template.New("mem.h").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#ifndef {{.IncludeGuard}}
#define {{.IncludeGuard}}

#include <cstdint>
#include <string>
#include <vector>
#include "{{.IncludePath}}bytes.h"

namespace {{.Namespace}} {

class Mem {
public:
  static constexpr int32_t kPageSize = 64 * 1024;

  Mem();

  int32_t GetSize() const;
  int32_t Grow(int32_t delta);

  int8_t LoadInt8(int32_t addr) const;
  uint8_t LoadUint8(int32_t addr) const;
  int16_t LoadInt16(int32_t addr) const;
  uint16_t LoadUint16(int32_t addr) const;
  int32_t LoadInt32(int32_t addr) const;
  uint32_t LoadUint32(int32_t addr) const;
  int64_t LoadInt64(int32_t addr) const;
  float LoadFloat32(int32_t addr) const;
  double LoadFloat64(int32_t addr) const;

  void StoreInt8(int32_t addr, int8_t val);
  void StoreInt16(int32_t addr, int16_t val);
  void StoreInt32(int32_t addr, int32_t val);
  void StoreInt64(int32_t addr, int64_t val);
  void StoreFloat32(int32_t addr, float val);
  void StoreFloat64(int32_t addr, double val);
  void StoreBytes(int32_t addr, const std::vector<uint8_t>& bytes);

  BytesSpan LoadSlice(int32_t addr);
  BytesSpan LoadSliceDirectly(int64_t array, int32_t len);
  std::string LoadString(int32_t addr) const;

private:
  Mem(const Mem&) = delete;
  Mem& operator=(const Mem&) = delete;

  std::vector<uint8_t> bytes_;
};

}

#endif  // {{.IncludeGuard}}
`))

var memCppTmpl = template.Must(template.New("mem.cpp").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#include "{{.IncludePath}}mem.h"

#include <algorithm>
#include <cstring>

namespace {{.Namespace}} {

namespace {

{{range $index, $value := .Data}}const uint8_t data_segment_data{{$index}}[] = {
  {{range $value2 := $value.Data}}{{$value2}}, {{end}}
};
{{end}}
}

Mem::Mem()
    : bytes_({{.InitPageNum}} * kPageSize) {
  bytes_.reserve(1ul * 1024 * 1024 * 1024);
{{range $index, $value := .Data}}  std::memcpy(&(bytes_[{{$value.Offset}}]), data_segment_data{{$index}}, {{len $value.Data}});
{{end}}
}

int32_t Mem::GetSize() const {
  return bytes_.size() / kPageSize;
}

int32_t Mem::Grow(int32_t delta) {
  constexpr size_t kMaxMemorySizeOnWasm = 4ul * 1024ul * 1024ul * 1024ul;

  int prev_size = GetSize();
  size_t new_size = (prev_size + delta) * kPageSize;
  if (bytes_.capacity() < new_size) {
    size_t new_capacity = bytes_.capacity();
    while (new_capacity < new_size) {
      new_capacity *= 2;
    }
    new_capacity = std::min(new_capacity, kMaxMemorySizeOnWasm);
    bytes_.reserve(new_capacity);
  }
  bytes_.resize((prev_size + delta) * kPageSize);
  return prev_size;
}

int8_t Mem::LoadInt8(int32_t addr) const {
  return static_cast<int8_t>(bytes_[addr]);
}

uint8_t Mem::LoadUint8(int32_t addr) const {
  return bytes_[addr];
}

int16_t Mem::LoadInt16(int32_t addr) const {
  return *(reinterpret_cast<const int16_t*>(&bytes_[addr]));
}

uint16_t Mem::LoadUint16(int32_t addr) const {
  return *(reinterpret_cast<const uint16_t*>(&bytes_[addr]));
}

int32_t Mem::LoadInt32(int32_t addr) const {
  return *(reinterpret_cast<const int32_t*>(&bytes_[addr]));
}

uint32_t Mem::LoadUint32(int32_t addr) const {
  return *(reinterpret_cast<const uint32_t*>(&bytes_[addr]));
}

int64_t Mem::LoadInt64(int32_t addr) const {
  return *(reinterpret_cast<const int64_t*>(&bytes_[addr]));
}

float Mem::LoadFloat32(int32_t addr) const {
  return *(reinterpret_cast<const float*>(&bytes_[addr]));
}

double Mem::LoadFloat64(int32_t addr) const {
  return *(reinterpret_cast<const double*>(&bytes_[addr]));
}

void Mem::StoreInt8(int32_t addr, int8_t val) {
  bytes_[addr] = static_cast<uint8_t>(val);
}

void Mem::StoreInt16(int32_t addr, int16_t val) {
  *(reinterpret_cast<int16_t*>(&bytes_[addr])) = val;
}

void Mem::StoreInt32(int32_t addr, int32_t val) {
  *(reinterpret_cast<int32_t*>(&bytes_[addr])) = val;
}

void Mem::StoreInt64(int32_t addr, int64_t val) {
  *(reinterpret_cast<int64_t*>(&bytes_[addr])) = val;
}

void Mem::StoreFloat32(int32_t addr, float val) {
  *(reinterpret_cast<float*>(&bytes_[addr])) = val;
}

void Mem::StoreFloat64(int32_t addr, double val) {
  *(reinterpret_cast<double*>(&bytes_[addr])) = val;
}

void Mem::StoreBytes(int32_t addr, const std::vector<uint8_t>& bytes) {
  std::copy(bytes.begin(), bytes.end(), bytes_.begin() + addr);
}

BytesSpan Mem::LoadSlice(int32_t addr) {
  int64_t array = LoadInt64(addr);
  int64_t len = LoadInt64(addr + 8);
  return BytesSpan{&*(bytes_.begin() + array), static_cast<BytesSpan::size_type>(len)};
}

BytesSpan Mem::LoadSliceDirectly(int64_t array, int32_t len) {
  return BytesSpan{&*(bytes_.begin() + array), static_cast<BytesSpan::size_type>(len)};
}

std::string Mem::LoadString(int32_t addr) const {
  int64_t saddr = LoadInt64(addr);
  int64_t len = LoadInt64(addr + 8);
  return std::string{bytes_.begin() + saddr, bytes_.begin() + saddr + len};
}

}
`))
