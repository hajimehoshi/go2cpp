// SPDX-License-Identifier: Apache-2.0

package gowasm2cpp

import (
	"os"
	"path/filepath"
	"text/template"
)

func writeJS(dir string, incpath string, namespace string) error {
	{
		f, err := os.Create(filepath.Join(dir, "js.h"))
		if err != nil {
			return err
		}
		defer f.Close()

		if err := jsHTmpl.Execute(f, struct {
			IncludeGuard string
			IncludePath  string
			Namespace    string
		}{
			IncludeGuard: includeGuard(namespace) + "_JS_H",
			IncludePath:  incpath,
			Namespace:    namespace,
		}); err != nil {
			return err
		}
	}
	{
		f, err := os.Create(filepath.Join(dir, "js.cpp"))
		if err != nil {
			return err
		}
		defer f.Close()

		if err := jsCppTmpl.Execute(f, struct {
			IncludePath string
			Namespace   string
		}{
			IncludePath: incpath,
			Namespace:   namespace,
		}); err != nil {
			return err
		}
	}
	return nil
}

var jsHTmpl = template.Must(template.New("js.h").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#ifndef {{.IncludeGuard}}
#define {{.IncludeGuard}}

#include "{{.IncludePath}}bytes.h"

#include <deque>
#include <dirent.h>
#include <functional>
#include <iostream>
#include <map>
#include <memory>
#include <string>
#include <vector>

namespace {{.Namespace}} {

class Object;

class Writer {
public:
  virtual ~Writer();
  virtual void Write(const std::vector<uint8_t>& bytes) = 0;
};

class StreamWriter : public Writer {
public:
  explicit StreamWriter(std::ostream& out);
  void Write(const std::vector<uint8_t>& bytes) override;

private:
  std::ostream& out_;
  // TODO: std::queue should be enough?
  std::deque<uint8_t> buf_;
};

class ArrayBuffer;

class Value {
public:
  enum class Type {
    Undefined,
    Null,
    Bool,
    Number,
    String,
    Object,
  };

  class Hash {
  public:
    std::size_t operator()(const Value& value) const;
  };

  static Value Null();
  static Value Global();
  static Value ReflectGet(Value target, const std::string& key);
  static void ReflectSet(Value target, const std::string& key, Value value);
  static void ReflectDelete(Value target, const std::string& key);
  static Value ReflectConstruct(Value target, std::vector<Value> args);
  static Value ReflectApply(Value target, Value self, std::vector<Value> args);

  Value();
  explicit Value(bool b);
  explicit Value(double num);
  explicit Value(const char* str);
  explicit Value(const std::string& str);
  explicit Value(std::shared_ptr<Object> object);
  explicit Value(const std::vector<Value>& array);

  Value(const Value& rhs);
  Value& operator=(const Value& rhs);
  bool operator==(const Value& rhs) const;

  bool IsNull() const;
  bool IsUndefined() const;
  bool IsBool() const;
  bool IsNumber() const;
  bool IsString() const;
  bool IsBytes() const;
  bool IsObject() const;
  bool IsArray() const;

  bool ToBool() const;
  double ToNumber() const;
  std::string ToString() const;
  BytesSpan ToBytes();
  Object& ToObject();
  const Object& ToObject() const;
  std::vector<Value>& ToArray();
  std::shared_ptr<ArrayBuffer> ToArrayBuffer();

  std::string Inspect() const;

private:
  static Value MakeGlobal();

  explicit Value(Type type);
  Value(Type type, double num);

  Type type_ = Type::Undefined;
  double num_value_ = 0;
  std::string str_value_;
  std::shared_ptr<Object> object_value_;
  std::shared_ptr<std::vector<Value>> array_value_;
};

class Object {
public:
  using Func = std::function<Value (Value, std::vector<Value>)>;

  virtual ~Object();
  virtual Value Get(const std::string& key);
  virtual void Set(const std::string& key, Value value);
  virtual void Delete(const std::string& key);

  virtual bool IsFunction() const { return false; }
  virtual bool IsConstructor() const { return false; }
  virtual bool IsBytes() const { return false; }
  virtual Value Invoke(Value self, std::vector<Value> args);
  virtual Value New(std::vector<Value> args);

  virtual BytesSpan ToBytes();

  virtual std::string ToString() const = 0;
  virtual std::string Inspect() const;
};

class ArrayBuffer : public Object {
public:
  explicit ArrayBuffer(size_t size);

  size_t ByteLength() const;
  Value Get(const std::string& key) override;
  bool IsBytes() const override;
  BytesSpan ToBytes() override;
  std::string ToString() const override;

private:
  std::vector<uint8_t> data_;
};

class TypedArray : public Object {
public:
  explicit TypedArray(size_t size);
  TypedArray(std::shared_ptr<ArrayBuffer> arrayBuffer, size_t offset, size_t length);

  Value Get(const std::string& key) override;
  void Set(const std::string& key, Value value) override;
  bool IsBytes() const override;
  BytesSpan ToBytes() override;
  std::string ToString() const override;

private:
  std::shared_ptr<ArrayBuffer> array_buffer_;
  size_t offset_ = 0;
  size_t length_ = 0;
};

class Uint8Array : public TypedArray {
public:
  explicit Uint8Array(size_t size);
  Uint8Array(std::shared_ptr<ArrayBuffer> arrayBuffer, size_t offset, size_t length);

  std::string ToString() const override;
};

class Float32Array : public TypedArray {
public:
  explicit Float32Array(size_t size);
  Float32Array(std::shared_ptr<ArrayBuffer> arrayBuffer, size_t offset, size_t length);

  std::string ToString() const override;
};

class DictionaryValues : public Object {
public:
  DictionaryValues();
  explicit DictionaryValues(const std::map<std::string, Value>& dict);

  Value Get(const std::string& key) override;
  void Set(const std::string& key, Value value) override;
  void Delete(const std::string& key) override;
  std::string ToString() const override;
  std::string Inspect() const override;

private:
  std::map<std::string, Value> dict_;
};

class Function : public Object {
public:
  explicit Function(Object::Func fn);
  Function(Object::Func fn, Value self);

  Value Get(const std::string& key) override;
  bool IsFunction() const override { return true; }
  bool IsConstructor() const override { return false; }
  Value Invoke(Value self, std::vector<Value> args) override;
  std::string ToString() const override { return "(function)"; }

private:
  Object::Func fn_;
  Value self_;
};

class Constructor : public Object {
public:
  Constructor(const std::string& name, Object::Func fn);

  bool IsFunction() const override { return true; }
  bool IsConstructor() const override { return true; }
  Value New(std::vector<Value> args) override;
  std::string ToString() const override;

private:
  std::string name_;
  Object::Func fn_;
};

}

#endif  // {{.IncludeGuard}}
`))

var jsCppTmpl = template.Must(template.New("js.cpp").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#include "{{.IncludePath}}js.h"

#include <algorithm>
#include <cassert>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <fcntl.h>
#include <iomanip>
#include <random>
#include <sstream>
#include <sys/stat.h>
#include <tuple>
#include <unistd.h>
#include <utime.h>

namespace {{.Namespace}} {

namespace {

void Panic(const std::string& msg) {
  std::cerr << msg << std::endl;
  __builtin_unreachable();
}

std::string JoinObjects(const std::vector<Value>& objs) {
  std::string str;
  for (int i = 0; i < objs.size(); i++) {
    str += objs[i].Inspect();
    if (i < objs.size() - 1) {
      str += ", ";
    }
  }
  return str;
}

void WriteObjects(std::ostream& out, const std::vector<Value>& objs) {
  std::vector<std::string> inspects(objs.size());
  for (int i = 0; i < objs.size(); i++) {
    out << objs[i].Inspect();
    if (i < objs.size() - 1) {
      out << ", ";
    }
  }
  out << std::endl;
}

const char* ToErrorCodeName(int errno_) {
  switch(errno_) {
#ifdef E2BIG
  case E2BIG: return "E2BIG";
#endif
#ifdef EACCES
  case EACCES: return "EACCES";
#endif
#ifdef EADDRINUSE
  case EADDRINUSE: return "EADDRINUSE";
#endif
#ifdef EADDRNOTAVAIL
  case EADDRNOTAVAIL: return "EADDRNOTAVAIL";
#endif
#ifdef EADI
  case EADI: return "EADI";
#endif
#ifdef EADV
  case EADV: return "EADV";
#endif
#ifdef EAFNOSUPPORT
  case EAFNOSUPPORT: return "EAFNOSUPPORT";
#endif
#ifdef EAGAIN
  case EAGAIN: return "EAGAIN";
#endif
#ifdef EAIO
  case EAIO: return "EAIO";
#endif
#ifdef EALIGN
  case EALIGN: return "EALIGN";
#endif
#ifdef EALREADY
  case EALREADY: return "EALREADY";
#endif
#ifdef EASYNC
  case EASYNC: return "EASYNC";
#endif
#ifdef EAUTH
  case EAUTH: return "EAUTH";
#endif
#ifdef EBADARCH
  case EBADARCH: return "EBADARCH";
#endif
#ifdef EBADE
  case EBADE: return "EBADE";
#endif
#ifdef EBADEXEC
  case EBADEXEC: return "EBADEXEC";
#endif
#ifdef EBADF
  case EBADF: return "EBADF";
#endif
#ifdef EBADFD
  case EBADFD: return "EBADFD";
#endif
#ifdef EBADMACHO
  case EBADMACHO: return "EBADMACHO";
#endif
#ifdef EBADMSG
  case EBADMSG: return "EBADMSG";
#endif
#ifdef EBADR
  case EBADR: return "EBADR";
#endif
#ifdef EBADRPC
  case EBADRPC: return "EBADRPC";
#endif
#ifdef EBADRQC
  case EBADRQC: return "EBADRQC";
#endif
#ifdef EBADSLT
  case EBADSLT: return "EBADSLT";
#endif
#ifdef EBADVER
  case EBADVER: return "EBADVER";
#endif
#ifdef EBFONT
  case EBFONT: return "EBFONT";
#endif
#ifdef EBUSY
  case EBUSY: return "EBUSY";
#endif
#ifdef ECANCELED
  case ECANCELED: return "ECANCELED";
#endif
#if defined(ECANCELLED) && (!defined(ECANCELED) || ECANCELLED != ECANCELED)
  case ECANCELLED: return "ECANCELLED";
#endif
#ifdef ECAPMODE
  case ECAPMODE: return "ECAPMODE";
#endif
#ifdef ECHILD
  case ECHILD: return "ECHILD";
#endif
#ifdef ECHRNG
  case ECHRNG: return "ECHRNG";
#endif
#ifdef ECKPT
  case ECKPT: return "ECKPT";
#endif
#ifdef ECLONEME
  case ECLONEME: return "ECLONEME";
#endif
#ifdef ECOMM
  case ECOMM: return "ECOMM";
#endif
#ifdef ECONFIG
  case ECONFIG: return "ECONFIG";
#endif
#ifdef ECONNABORTED
  case ECONNABORTED: return "ECONNABORTED";
#endif
#ifdef ECONNREFUSED
  case ECONNREFUSED: return "ECONNREFUSED";
#endif
#ifdef ECONNRESET
  case ECONNRESET: return "ECONNRESET";
#endif
#ifdef ECORRUPT
  case ECORRUPT: return "ECORRUPT";
#endif
#ifdef ECVCERORR
  case ECVCERORR: return "ECVCERORR";
#endif
#ifdef ECVPERORR
  case ECVPERORR: return "ECVPERORR";
#endif
#ifdef EDEADLK
  case EDEADLK: return "EDEADLK";
#endif
#if defined(EDEADLOCK) && (!defined(EDEADLK) || EDEADLOCK != EDEADLK)
  case EDEADLOCK: return "EDEADLOCK";
#endif
#ifdef EDESTADDREQ
  case EDESTADDREQ: return "EDESTADDREQ";
#endif
#ifdef EDESTADDRREQ
  case EDESTADDRREQ: return "EDESTADDRREQ";
#endif
#ifdef EDEVERR
  case EDEVERR: return "EDEVERR";
#endif
#ifdef EDIRIOCTL
  case EDIRIOCTL: return "EDIRIOCTL";
#endif
#ifdef EDIRTY
  case EDIRTY: return "EDIRTY";
#endif
#ifdef EDIST
  case EDIST: return "EDIST";
#endif
#ifdef EDOM
  case EDOM: return "EDOM";
#endif
#ifdef EDOOFUS
  case EDOOFUS: return "EDOOFUS";
#endif
#ifdef EDOTDOT
  case EDOTDOT: return "EDOTDOT";
#endif
#ifdef EDQUOT
  case EDQUOT: return "EDQUOT";
#endif
#ifdef EDUPFD
  case EDUPFD: return "EDUPFD";
#endif
#ifdef EDUPPKG
  case EDUPPKG: return "EDUPPKG";
#endif
#ifdef EEXIST
  case EEXIST: return "EEXIST";
#endif
#ifdef EFAIL
  case EFAIL: return "EFAIL";
#endif
#ifdef EFAULT
  case EFAULT: return "EFAULT";
#endif
#ifdef EFBIG
  case EFBIG: return "EFBIG";
#endif
#ifdef EFORMAT
  case EFORMAT: return "EFORMAT";
#endif
#ifdef EFSCORRUPTED
  case EFSCORRUPTED: return "EFSCORRUPTED";
#endif
#ifdef EFTYPE
  case EFTYPE: return "EFTYPE";
#endif
#ifdef EHOSTDOWN
  case EHOSTDOWN: return "EHOSTDOWN";
#endif
#ifdef EHOSTUNREACH
  case EHOSTUNREACH: return "EHOSTUNREACH";
#endif
#ifdef EHWPOISON
  case EHWPOISON: return "EHWPOISON";
#endif
#ifdef EIDRM
  case EIDRM: return "EIDRM";
#endif
#ifdef EILSEQ
  case EILSEQ: return "EILSEQ";
#endif
#ifdef EINIT
  case EINIT: return "EINIT";
#endif
#ifdef EINPROG
  case EINPROG: return "EINPROG";
#endif
#ifdef EINPROGRESS
  case EINPROGRESS: return "EINPROGRESS";
#endif
#ifdef EINTEGRITY
  case EINTEGRITY: return "EINTEGRITY";
#endif
#ifdef EINTR
  case EINTR: return "EINTR";
#endif
#ifdef EINVAL
  case EINVAL: return "EINVAL";
#endif
#ifdef EIO
  case EIO: return "EIO";
#endif
#ifdef EIPSEC
  case EIPSEC: return "EIPSEC";
#endif
#ifdef EISCONN
  case EISCONN: return "EISCONN";
#endif
#ifdef EISDIR
  case EISDIR: return "EISDIR";
#endif
#ifdef EISNAM
  case EISNAM: return "EISNAM";
#endif
#ifdef EJUSTRETURN
  case EJUSTRETURN: return "EJUSTRETURN";
#endif
#ifdef EKEEPLOOKING
  case EKEEPLOOKING: return "EKEEPLOOKING";
#endif
#ifdef EKEYEXPIRED
  case EKEYEXPIRED: return "EKEYEXPIRED";
#endif
#ifdef EKEYREJECTED
  case EKEYREJECTED: return "EKEYREJECTED";
#endif
#ifdef EKEYREVOKED
  case EKEYREVOKED: return "EKEYREVOKED";
#endif
#ifdef EL2HLT
  case EL2HLT: return "EL2HLT";
#endif
#ifdef EL2NSYNC
  case EL2NSYNC: return "EL2NSYNC";
#endif
#ifdef EL3HLT
  case EL3HLT: return "EL3HLT";
#endif
#ifdef EL3RST
  case EL3RST: return "EL3RST";
#endif
#ifdef ELIBACC
  case ELIBACC: return "ELIBACC";
#endif
#ifdef ELIBBAD
  case ELIBBAD: return "ELIBBAD";
#endif
#ifdef ELIBEXEC
  case ELIBEXEC: return "ELIBEXEC";
#endif
#ifdef ELIBMAX
  case ELIBMAX: return "ELIBMAX";
#endif
#ifdef ELIBSCN
  case ELIBSCN: return "ELIBSCN";
#endif
#ifdef ELNRNG
  case ELNRNG: return "ELNRNG";
#endif
#ifdef ELOCKUNMAPPED
  case ELOCKUNMAPPED: return "ELOCKUNMAPPED";
#endif
#ifdef ELOOP
  case ELOOP: return "ELOOP";
#endif
#ifdef EMEDIA
  case EMEDIA: return "EMEDIA";
#endif
#ifdef EMEDIUMTYPE
  case EMEDIUMTYPE: return "EMEDIUMTYPE";
#endif
#ifdef EMFILE
  case EMFILE: return "EMFILE";
#endif
#ifdef EMLINK
  case EMLINK: return "EMLINK";
#endif
#ifdef EMOUNTEXIT
  case EMOUNTEXIT: return "EMOUNTEXIT";
#endif
#ifdef EMOVEFD
  case EMOVEFD: return "EMOVEFD";
#endif
#ifdef EMSGSIZE
  case EMSGSIZE: return "EMSGSIZE";
#endif
#ifdef EMTIMERS
  case EMTIMERS: return "EMTIMERS";
#endif
#ifdef EMULTIHOP
  case EMULTIHOP: return "EMULTIHOP";
#endif
#ifdef ENAMETOOLONG
  case ENAMETOOLONG: return "ENAMETOOLONG";
#endif
#ifdef ENAVAIL
  case ENAVAIL: return "ENAVAIL";
#endif
#ifdef ENEEDAUTH
  case ENEEDAUTH: return "ENEEDAUTH";
#endif
#ifdef ENETDOWN
  case ENETDOWN: return "ENETDOWN";
#endif
#ifdef ENETRESET
  case ENETRESET: return "ENETRESET";
#endif
#ifdef ENETUNREACH
  case ENETUNREACH: return "ENETUNREACH";
#endif
#ifdef ENFILE
  case ENFILE: return "ENFILE";
#endif
#ifdef ENFSREMOTE
  case ENFSREMOTE: return "ENFSREMOTE";
#endif
#ifdef ENOANO
  case ENOANO: return "ENOANO";
#endif
#ifdef ENOATTR
  case ENOATTR: return "ENOATTR";
#endif
#ifdef ENOBUFS
  case ENOBUFS: return "ENOBUFS";
#endif
#ifdef ENOCONNECT
  case ENOCONNECT: return "ENOCONNECT";
#endif
#ifdef ENOCSI
  case ENOCSI: return "ENOCSI";
#endif
#ifdef ENODATA
  case ENODATA: return "ENODATA";
#endif
#ifdef ENODEV
  case ENODEV: return "ENODEV";
#endif
#ifdef ENOENT
  case ENOENT: return "ENOENT";
#endif
#ifdef ENOEXEC
  case ENOEXEC: return "ENOEXEC";
#endif
#ifdef ENOIOCTL
  case ENOIOCTL: return "ENOIOCTL";
#endif
#ifdef ENOKEY
  case ENOKEY: return "ENOKEY";
#endif
#ifdef ENOLCK
  case ENOLCK: return "ENOLCK";
#endif
#ifdef ENOLINK
  case ENOLINK: return "ENOLINK";
#endif
#ifdef ENOLOAD
  case ENOLOAD: return "ENOLOAD";
#endif
#ifdef ENOMATCH
  case ENOMATCH: return "ENOMATCH";
#endif
#ifdef ENOMEDIUM
  case ENOMEDIUM: return "ENOMEDIUM";
#endif
#ifdef ENOMEM
  case ENOMEM: return "ENOMEM";
#endif
#ifdef ENOMSG
  case ENOMSG: return "ENOMSG";
#endif
#ifdef ENONET
  case ENONET: return "ENONET";
#endif
#ifdef ENOPKG
  case ENOPKG: return "ENOPKG";
#endif
#ifdef ENOPOLICY
  case ENOPOLICY: return "ENOPOLICY";
#endif
#ifdef ENOPROTOOPT
  case ENOPROTOOPT: return "ENOPROTOOPT";
#endif
#ifdef ENOREG
  case ENOREG: return "ENOREG";
#endif
#ifdef ENOSPC
  case ENOSPC: return "ENOSPC";
#endif
#ifdef ENOSR
  case ENOSR: return "ENOSR";
#endif
#ifdef ENOSTR
  case ENOSTR: return "ENOSTR";
#endif
#ifdef ENOSYM
  case ENOSYM: return "ENOSYM";
#endif
#ifdef ENOSYS
  case ENOSYS: return "ENOSYS";
#endif
#ifdef ENOTACTIVE
  case ENOTACTIVE: return "ENOTACTIVE";
#endif
#ifdef ENOTBLK
  case ENOTBLK: return "ENOTBLK";
#endif
#ifdef ENOTCAPABLE
  case ENOTCAPABLE: return "ENOTCAPABLE";
#endif
#ifdef ENOTCONN
  case ENOTCONN: return "ENOTCONN";
#endif
#ifdef ENOTDIR
  case ENOTDIR: return "ENOTDIR";
#endif
#ifdef ENOTEMPTY
  case ENOTEMPTY: return "ENOTEMPTY";
#endif
#ifdef ENOTNAM
  case ENOTNAM: return "ENOTNAM";
#endif
#ifdef ENOTREADY
  case ENOTREADY: return "ENOTREADY";
#endif
#ifdef ENOTRECOVERABLE
  case ENOTRECOVERABLE: return "ENOTRECOVERABLE";
#endif
#ifdef ENOTRUST
  case ENOTRUST: return "ENOTRUST";
#endif
#ifdef ENOTSOCK
  case ENOTSOCK: return "ENOTSOCK";
#endif
#ifdef ENOTSUP
  case ENOTSUP: return "ENOTSUP";
#endif
#ifdef ENOTTY
  case ENOTTY: return "ENOTTY";
#endif
#ifdef ENOTUNIQ
  case ENOTUNIQ: return "ENOTUNIQ";
#endif
#ifdef ENOUNLD
  case ENOUNLD: return "ENOUNLD";
#endif
#ifdef ENOUNREG
  case ENOUNREG: return "ENOUNREG";
#endif
#ifdef ENXIO
  case ENXIO: return "ENXIO";
#endif
#ifdef EOPCOMPLETE
  case EOPCOMPLETE: return "EOPCOMPLETE";
#endif
#if defined(EOPNOTSUPP) && (!defined(ENOTSUP) || EOPNOTSUPP != ENOTSUP)
  case EOPNOTSUPP: return "EOPNOTSUPP";
#endif
#ifdef EOVERFLOW
  case EOVERFLOW: return "EOVERFLOW";
#endif
#ifdef EOWNERDEAD
  case EOWNERDEAD: return "EOWNERDEAD";
#endif
#ifdef EPASSTHROUGH
  case EPASSTHROUGH: return "EPASSTHROUGH";
#endif
#ifdef EPATHREMOTE
  case EPATHREMOTE: return "EPATHREMOTE";
#endif
#ifdef EPERM
  case EPERM: return "EPERM";
#endif
#ifdef EPFNOSUPPORT
  case EPFNOSUPPORT: return "EPFNOSUPPORT";
#endif
#ifdef EPIPE
  case EPIPE: return "EPIPE";
#endif
#ifdef EPOWERF
  case EPOWERF: return "EPOWERF";
#endif
#ifdef EPROCLIM
  case EPROCLIM: return "EPROCLIM";
#endif
#ifdef EPROCUNAVAIL
  case EPROCUNAVAIL: return "EPROCUNAVAIL";
#endif
#ifdef EPROGMISMATCH
  case EPROGMISMATCH: return "EPROGMISMATCH";
#endif
#ifdef EPROGUNAVAIL
  case EPROGUNAVAIL: return "EPROGUNAVAIL";
#endif
#ifdef EPROTO
  case EPROTO: return "EPROTO";
#endif
#ifdef EPROTONOSUPPORT
  case EPROTONOSUPPORT: return "EPROTONOSUPPORT";
#endif
#ifdef EPROTOTYPE
  case EPROTOTYPE: return "EPROTOTYPE";
#endif
#ifdef EPWROFF
  case EPWROFF: return "EPWROFF";
#endif
#ifdef EQFULL
  case EQFULL: return "EQFULL";
#endif
#ifdef EQSUSPENDED
  case EQSUSPENDED: return "EQSUSPENDED";
#endif
#ifdef ERANGE
  case ERANGE: return "ERANGE";
#endif
#ifdef ERECYCLE
  case ERECYCLE: return "ERECYCLE";
#endif
#ifdef EREDRIVEOPEN
  case EREDRIVEOPEN: return "EREDRIVEOPEN";
#endif
#ifdef EREFUSED
  case EREFUSED: return "EREFUSED";
#endif
#ifdef ERELOC
  case ERELOC: return "ERELOC";
#endif
#ifdef ERELOCATED
  case ERELOCATED: return "ERELOCATED";
#endif
#ifdef ERELOOKUP
  case ERELOOKUP: return "ERELOOKUP";
#endif
#ifdef EREMCHG
  case EREMCHG: return "EREMCHG";
#endif
#ifdef EREMDEV
  case EREMDEV: return "EREMDEV";
#endif
#ifdef EREMOTE
  case EREMOTE: return "EREMOTE";
#endif
#ifdef EREMOTEIO
  case EREMOTEIO: return "EREMOTEIO";
#endif
#ifdef EREMOTERELEASE
  case EREMOTERELEASE: return "EREMOTERELEASE";
#endif
#ifdef ERESTART
  case ERESTART: return "ERESTART";
#endif
#ifdef ERFKILL
  case ERFKILL: return "ERFKILL";
#endif
#ifdef EROFS
  case EROFS: return "EROFS";
#endif
#ifdef ERPCMISMATCH
  case ERPCMISMATCH: return "ERPCMISMATCH";
#endif
#ifdef ESAD
  case ESAD: return "ESAD";
#endif
#ifdef ESHLIBVERS
  case ESHLIBVERS: return "ESHLIBVERS";
#endif
#ifdef ESHUTDOWN
  case ESHUTDOWN: return "ESHUTDOWN";
#endif
#ifdef ESOCKTNOSUPPORT
  case ESOCKTNOSUPPORT: return "ESOCKTNOSUPPORT";
#endif
#ifdef ESOFT
  case ESOFT: return "ESOFT";
#endif
#ifdef ESPIPE
  case ESPIPE: return "ESPIPE";
#endif
#ifdef ESRCH
  case ESRCH: return "ESRCH";
#endif
#ifdef ESRMNT
  case ESRMNT: return "ESRMNT";
#endif
#ifdef ESTALE
  case ESTALE: return "ESTALE";
#endif
#ifdef ESTART
  case ESTART: return "ESTART";
#endif
#ifdef ESTRPIPE
  case ESTRPIPE: return "ESTRPIPE";
#endif
#ifdef ESYSERROR
  case ESYSERROR: return "ESYSERROR";
#endif
#ifdef ETIME
  case ETIME: return "ETIME";
#endif
#ifdef ETIMEDOUT
  case ETIMEDOUT: return "ETIMEDOUT";
#endif
#ifdef ETOOMANYREFS
  case ETOOMANYREFS: return "ETOOMANYREFS";
#endif
#ifdef ETXTBSY
  case ETXTBSY: return "ETXTBSY";
#endif
#ifdef EUCLEAN
  case EUCLEAN: return "EUCLEAN";
#endif
#ifdef EUNATCH
  case EUNATCH: return "EUNATCH";
#endif
#ifdef EUSERS
  case EUSERS: return "EUSERS";
#endif
#ifdef EVERSION
  case EVERSION: return "EVERSION";
#endif
#if defined(EWOULDBLOCK) && (!defined(EAGAIN) || EWOULDBLOCK != EAGAIN)
  case EWOULDBLOCK: return "EWOULDBLOCK";
#endif
#ifdef EWRONGFS
  case EWRONGFS: return "EWRONGFS";
#endif
#ifdef EWRPROTECT
  case EWRPROTECT: return "EWRPROTECT";
#endif
#ifdef EXDEV
  case EXDEV: return "EXDEV";
#endif
#ifdef EXFULL
  case EXFULL: return "EXFULL";
#endif
  }
  return "";
}

class Errno : public Object {
public:
  explicit Errno(int errno_)
      : errno_(errno_) {
  }

  Value Get(const std::string& key) override {
    if (key == "message") {
      return Value{ToString()};
    }
    if (key == "code") {
      return Value{ToErrorCodeName(errno_)};
    }
    return Value{};
  }

  std::string ToString() const override {
    return std::strerror(errno_);
  }

private:
  const int errno_;
};

// TODO: Use Error.
class Enosys : public Object {
public:
  explicit Enosys(const std::string& name)
      : name_(name) {
  }

  Value Get(const std::string& key) override {
    if (key == "message") {
      return Value{name_ + " not implemented"};
    }
    if (key == "code") {
      return Value{"ENOSYS"};
    }
    return Value{};
  }

  std::string ToString() const override {
    return "ENOSYS: " + name_;
  }

private:
  std::string name_;
};

class FS : public Object {
public:
  FS() {
    constants_ = Value{std::make_shared<DictionaryValues>(std::map<std::string, Value>{
      {"O_WRONLY", Value{static_cast<double>(O_WRONLY)}},
      {"O_RDWR", Value{static_cast<double>(O_RDWR)}},
      {"O_CREAT", Value{static_cast<double>(O_CREAT)}},
      {"O_TRUNC", Value{static_cast<double>(O_TRUNC)}},
      {"O_APPEND", Value{static_cast<double>(O_APPEND)}},
      {"O_EXCL", Value{static_cast<double>(O_EXCL)}},
    })};
  }

  Value Get(const std::string& key) override {
    if (key == "constants") {
      return constants_;
    }
    if (key == "write") {
      return Value{std::make_shared<Function>(
        [](Value self, std::vector<Value> args) -> Value {
          int fd = static_cast<int>(args[0].ToNumber());
          BytesSpan buf = args[1].ToBytes();
          size_t offset = static_cast<size_t>(args[2].ToNumber());
          size_t length = static_cast<size_t>(args[3].ToNumber());
          Value position = args[4];
          Value callback = args[5];
          size_t n;
          if (position.IsNumber()) {
            n = pwrite(fd, buf.begin() + offset, length, static_cast<off_t>(position.ToNumber()));
          } else {
            n = write(fd, buf.begin() + offset, length);
          }
          Value errval = Value::Null();
          if (n == -1) {
            errval = Value{std::make_shared<Errno>(errno)};
          }
          Value::ReflectApply(callback, Value{}, {errval, Value{static_cast<double>(n)}});
          return Value{};
        })};
    }
    if (key == "close") {
      return Value{std::make_shared<Function>(
        [](Value self, std::vector<Value> args) -> Value {
          int fd = static_cast<int>(args[0].ToNumber());
          Value callback = args[1];
          Value errval = Value::Null();
          if (close(fd)) {
            errval = Value{std::make_shared<Errno>(errno)};
          }
          Value::ReflectApply(callback, Value{}, {errval});
          return Value{};
        })};
    }
    if (key == "fstat") {
      return Value{std::make_shared<Function>(
        [this](Value self, std::vector<Value> args) -> Value {
          int fd = static_cast<int>(args[0].ToNumber());
          Value callback = args[1];
          struct stat statbuf;
          Value errval = Value::Null();
          if (fstat(fd, &statbuf)) {
            errval = Value{std::make_shared<Errno>(errno)};
          }
          Value::ReflectApply(callback, Value{}, {errval, StatToValue(&statbuf)});
          return Value{};
        })};
    }
    if (key == "ftruncate") {
      return Value{std::make_shared<Function>(
        [](Value self, std::vector<Value> args) -> Value {
          int fd = static_cast<int>(args[0].ToNumber());
          off_t len = static_cast<off_t>(args[1].ToNumber());
          Value callback = args[2];
          Value errval = Value::Null();
          if (ftruncate(fd, len)) {
            errval = Value{std::make_shared<Errno>(errno)};
          }
          Value::ReflectApply(callback, Value{}, {errval});
          return Value{};
        })};
    }
    if (key == "lstat") {
      // Unfortunately, lstat might not be defined in some platforms.
#if 0
      return Value{std::make_shared<Function>(
        [this](Value self, std::vector<Value> args) -> Value {
          std::string path = args[0].ToString();
          Value callback = args[1];
          struct stat statbuf;
          Value errval = Value::Null();
          if (lstat(path.c_str(), &statbuf)) {
            errval = Value{std::make_shared<Errno>(errno)};
          }
          Value::ReflectApply(callback, Value{}, {errval, StatToValue(&statbuf)});
          return Value{};
        })};
#endif
    }
    if (key == "mkdir") {
      return Value{std::make_shared<Function>(
        [](Value self, std::vector<Value> args) -> Value {
          std::string path = args[0].ToString();
          int perm = static_cast<int>(args[1].ToNumber());
          Value callback = args[2];
          Value errval = Value::Null();
          if (mkdir(path.c_str(), perm)) {
            errval = Value{std::make_shared<Errno>(errno)};
          }
          Value::ReflectApply(callback, Value{}, {errval});
          return Value{};
        })};
    }
    if (key == "open") {
      return Value{std::make_shared<Function>(
        [](Value self, std::vector<Value> args) -> Value {
          std::string path = args[0].ToString();
          int flags = static_cast<int>(args[1].ToNumber());
          mode_t mode = static_cast<mode_t>(args[2].ToNumber());
          Value callback = args[3];
          int fd = open(path.c_str(), flags, mode);
          Value errval = Value::Null();
          if (fd == -1) {
            errval = Value{std::make_shared<Errno>(errno)};
          }
          Value::ReflectApply(callback, Value{}, {errval, Value{static_cast<double>(fd)}});
          return Value{};
        })};
    }
    if (key == "read") {
      return Value{std::make_shared<Function>(
        [](Value self, std::vector<Value> args) -> Value {
          int fd = static_cast<int>(args[0].ToNumber());
          BytesSpan buf = args[1].ToBytes();
          size_t offset = static_cast<size_t>(args[2].ToNumber());
          size_t length = static_cast<size_t>(args[3].ToNumber());
          Value position = args[4];
          Value callback = args[5];
          size_t n;
          if (position.IsNumber()) {
            n = pread(fd, buf.begin() + offset, length, static_cast<off_t>(position.ToNumber()));
          } else {
            n = read(fd, buf.begin() + offset, length);
          }
          Value errval = Value::Null();
          if (n == -1) {
            errval = Value{std::make_shared<Errno>(errno)};
          }
          Value::ReflectApply(callback, Value{}, {errval, Value{static_cast<double>(n)}});
          return Value{};
        })};
    }
    if (key == "readdir") {
      return Value{std::make_shared<Function>(
        [](Value self, std::vector<Value> args) -> Value {
          std::string path = args[0].ToString();
          Value callback = args[1];

          DIR* dir = opendir(path.c_str());
          if (!dir) {
            Value errval = Value{std::make_shared<Errno>(errno)};
            Value::ReflectApply(callback, Value{}, {errval, Value{}});
            return Value{};
          }

          struct dirent* dp;
          std::vector<Value> filenames;
          while ((dp = readdir(dir)) != nullptr) {
            std::string filename = dp->d_name;
            if (filename == "." || filename == "..") {
              continue;
            }
            filenames.push_back(Value{filename});
          }
          // readdir can set an error value.
          if (errno) {
            Value errval = Value{std::make_shared<Errno>(errno)};
            Value::ReflectApply(callback, Value{}, {errval, Value{}});
            return Value{};
          }

          if (!closedir(dir)) {
            Value errval = Value{std::make_shared<Errno>(errno)};
            Value::ReflectApply(callback, Value{}, {errval, Value{}});
            return Value{};
          }

          Value::ReflectApply(callback, Value{}, {Value::Null(), Value{filenames}});
          return Value{};
        })};
    }
    if (key == "rename") {
      return Value{std::make_shared<Function>(
        [](Value self, std::vector<Value> args) -> Value {
          std::string old_path = args[0].ToString();
          std::string new_path = args[1].ToString();
          Value callback = args[2];
          Value errval = Value::Null();
          if (rename(old_path.c_str(), new_path.c_str())) {
            errval = Value{std::make_shared<Errno>(errno)};
          }
          Value::ReflectApply(callback, Value{}, {errval});
          return Value{};
        })};
    }
    if (key == "rmdir") {
      return Value{std::make_shared<Function>(
        [](Value self, std::vector<Value> args) -> Value {
          std::string path = args[0].ToString();
          Value callback = args[1];
          Value errval = Value::Null();
          if (rmdir(path.c_str())) {
            errval = Value{std::make_shared<Errno>(errno)};
          }
          Value::ReflectApply(callback, Value{}, {errval});
          return Value{};
        })};
    }
    if (key == "stat") {
      return Value{std::make_shared<Function>(
        [this](Value self, std::vector<Value> args) -> Value {
          std::string path = args[0].ToString();
          Value callback = args[1];
          struct stat statbuf;
          Value errval = Value::Null();
          if (stat(path.c_str(), &statbuf)) {
            errval = Value{std::make_shared<Errno>(errno)};
          }
          Value::ReflectApply(callback, Value{}, {errval, StatToValue(&statbuf)});
          return Value{};
        })};
    }
    if (key == "unlink") {
      return Value{std::make_shared<Function>(
        [](Value self, std::vector<Value> args) -> Value {
          std::string path = args[0].ToString();
          Value callback = args[1];
          Value errval = Value::Null();
          if (unlink(path.c_str())) {
            errval = Value{std::make_shared<Errno>(errno)};
          }
          Value::ReflectApply(callback, Value{}, {errval});
          return Value{};
        })};
    }
    if (key == "utimes") {
      // Unfortunately, utime(s) might not be defined in some platforms.
#if 0
      return Value{std::make_shared<Function>(
        [](Value self, std::vector<Value> args) -> Value {
          std::string path = args[0].ToString();
          time_t atime = static_cast<time_t>(args[1].ToNumber());
          time_t mtime = static_cast<time_t>(args[2].ToNumber());
          Value callback = args[3];
          Value errval = Value::Null();
          struct utimbuf times;
          times.actime = atime;
          times.modtime = mtime;
          if (utime(path.c_str(), &times)) {
            errval = Value{std::make_shared<Errno>(errno)};
          }
          Value::ReflectApply(callback, Value{}, {errval});
          return Value{};
        })};
#endif
    }

    Panic(key + " on fs is not implemented");
    return Value{};
  }

  std::string ToString() const override {
    return "fs";
  }

private:
  Value StatToValue(struct stat* statbuf) {
    auto dict = std::make_shared<DictionaryValues>();
    dict->Set("dev", Value{static_cast<double>(statbuf->st_dev)});
    dict->Set("ino", Value{static_cast<double>(statbuf->st_ino)});
    dict->Set("mode", Value{static_cast<double>(statbuf->st_mode)});
    dict->Set("nlink", Value{static_cast<double>(statbuf->st_nlink)});
    dict->Set("uid", Value{static_cast<double>(statbuf->st_uid)});
    dict->Set("gid", Value{static_cast<double>(statbuf->st_gid)});
    dict->Set("rdev", Value{static_cast<double>(statbuf->st_rdev)});
    dict->Set("size", Value{static_cast<double>(statbuf->st_size)});
    dict->Set("blksize", Value{static_cast<double>(statbuf->st_blksize)});
    dict->Set("blocks", Value{static_cast<double>(statbuf->st_blocks)});

#if defined(__APPLE__)
    dict->Set("atimMs", Value{static_cast<double>(TimespecToMillisecond(&statbuf->st_atimespec))});
    dict->Set("mtimMs", Value{static_cast<double>(TimespecToMillisecond(&statbuf->st_mtimespec))});
    dict->Set("ctimMs", Value{static_cast<double>(TimespecToMillisecond(&statbuf->st_ctimespec))});
#else
    dict->Set("atimMs", Value{static_cast<double>(TimespecToMillisecond(&statbuf->st_atim))});
    dict->Set("mtimMs", Value{static_cast<double>(TimespecToMillisecond(&statbuf->st_mtim))});
    dict->Set("ctimMs", Value{static_cast<double>(TimespecToMillisecond(&statbuf->st_ctim))});
#endif

    bool dir = statbuf->st_mode & S_IFDIR;
    dict->Set("isDirectory", Value{std::make_shared<Function>(
        [dir](Value self, std::vector<Value> args) -> Value {
          return Value{dir};
        })});
    return Value{dict};
  }

  int64_t TimespecToMillisecond(struct timespec* t) {
    return static_cast<int64_t>(t->tv_sec) * 1000ll +
        static_cast<int64_t>(t->tv_nsec) / 1000000ll;
  }

  Value constants_;
};

class Process : public Object {
public:
  Value Get(const std::string& key) override {
    if (key == "pid") {
      return Value{-1.0};
    }
    if (key == "ppid") {
      return Value{-1.0};
    }
    if (key == "cwd") {
      return Value{std::make_shared<Function>(
        [](Value self, std::vector<Value> args) -> Value {
          char path[PATH_MAX];
          if (!getcwd(path, PATH_MAX)) {
            Panic(std::string("getcwd failed: ") + std::strerror(errno));
            return Value{};
          }
          return Value{path};
        })};
    }
    Panic(key + " on process is not implemented");
    return Value{};
  }

  std::string ToString() const override {
    return "process";
  }
};

class Date : public Object {
public:
  Value Get(const std::string& key) override {
    if (key == "getTimezoneOffset") {
      return Value{std::make_shared<Function>(
        [](Value self, std::vector<Value> args) -> Value {
          std::time_t time = std::time(nullptr);
          std::tm tm = *std::localtime(&time);
          std::ostringstream os;
          os << std::put_time(&tm, "%z");
          std::string str = os.str();
          int h = std::stoi(str.substr(0, 3), nullptr, 10);
          int m = std::stoi(str[0]+str.substr(3), nullptr, 10);
          return Value{static_cast<double>(h*60 + m) * -1};
        })};
    }
    Panic(key + " on Date is not implemented");
    return Value{};
  }

  std::string ToString() const override {
    return "Date";
  }
};

}  // namespace

Writer::~Writer() = default;

StreamWriter::StreamWriter(std::ostream& out)
    : out_{out} {
}

void StreamWriter::Write(const std::vector<uint8_t>& bytes) {
  buf_.insert(buf_.end(), bytes.begin(), bytes.end());
  for (;;) {
    auto it = std::find(buf_.begin(), buf_.end(), '\n');
    if (it == buf_.end()) {
      break;
    }
    std::string str(buf_.begin(), it);
    out_ << str << std::endl;
    ++it;
    buf_.erase(buf_.begin(), it);
  }
}

std::size_t Value::Hash::operator()(const Value& value) const {
  size_t h = 17;
  h = h * 31 + std::hash<decltype(value.type_)>()(value.type_);
  h = h * 31 + std::hash<decltype(value.num_value_)>()(value.num_value_);
  h = h * 31 + std::hash<decltype(value.str_value_)>()(value.str_value_);
  h = h * 31 + std::hash<decltype(value.object_value_)>()(value.object_value_);
  h = h * 31 + std::hash<decltype(value.array_value_)>()(value.array_value_);
  return h;
}

Value Value::Null() {
  return Value{Type::Null};
}

Value::Value() = default;

Value::Value(bool b)
    : type_{Type::Bool},
      num_value_{static_cast<double>(b)}{
}

Value::Value(double num)
    : type_{Type::Number},
      num_value_{num} {
}

Value::Value(const char* str)
    : Value{std::string(str)} {
}

Value::Value(const std::string& str)
    : type_{Type::String},
      str_value_{str} {
}

Value::Value(std::shared_ptr<Object> object)
    : type_{Type::Object},
      object_value_{object} {
}

Value::Value(const std::vector<Value>& array)
    : type_{Type::Object},
      array_value_{std::make_shared<std::vector<Value>>(array.begin(), array.end())} {
}

Value::Value(const Value& rhs) = default;

Value& Value::operator=(const Value& rhs) = default;

bool Value::operator==(const Value& rhs) const {
  return type_ == rhs.type_ &&
      num_value_ == rhs.num_value_ &&
      str_value_ == rhs.str_value_ &&
      object_value_ == rhs.object_value_ &&
      array_value_ == rhs.array_value_;
}

Value::Value(Type type)
    : type_{type} {
}

Value::Value(Type type, double num)
    : type_{type},
      num_value_{num} {
}

bool Value::IsNull() const {
  return type_ == Type::Null;
}

bool Value::IsUndefined() const {
  return type_ == Type::Undefined;
}

bool Value::IsBool() const {
  return type_ == Type::Bool;
}

bool Value::IsNumber() const {
  return type_ == Type::Number;
}

bool Value::IsString() const {
  return type_ == Type::String;
}

bool Value::IsBytes() const {
  return type_ == Type::Object && object_value_->IsBytes();
}

bool Value::IsObject() const {
  return type_ == Type::Object && !!object_value_;
}

bool Value::IsArray() const {
  return type_ == Type::Object && !!array_value_;
}

bool Value::ToBool() const {
  if (type_ != Type::Bool) {
    Panic("Value::ToBool: the type must be Type::Bool but not: " + Inspect());
  }
  return static_cast<bool>(num_value_);
}

double Value::ToNumber() const {
  if (type_ != Type::Number) {
    Panic("Value::ToNumber: the type must be Type::Number but not: " + Inspect());
  }
  return num_value_;
}

std::string Value::ToString() const {
  if (type_ != Type::String) {
    Panic("Value::ToString: the type must be Type::String but not: " + Inspect());
  }
  return str_value_;
}

BytesSpan Value::ToBytes() {
  if (type_ != Type::Object) {
    Panic("Value::ToBytes: the type must be Type::Object but not: " + Inspect());
  }
  if (!object_value_) {
    Panic("Value::ToBytes: object_value_ must not be null");
  }
  if (!object_value_->IsBytes()) {
    Panic("Value::ToBytes: object_value_->IsBytes() must be true");
  }
  return object_value_->ToBytes();
}

Object& Value::ToObject() {
  if (type_ != Type::Object) {
    Panic("Value::ToObject: the type must be Type::Object but not: " + Inspect());
  }
  if (!object_value_) {
    Panic("Value::ToObject: object_value_ must not be null");
  }
  return *object_value_;
}

const Object& Value::ToObject() const {
  if (type_ != Type::Object) {
    Panic("Value::ToObject: the type must be Type::Object but not: " + Inspect());
  }
  if (!object_value_) {
    Panic("Value::ToObject: object_value_ must not be null");
  }
  return *object_value_;
}

std::vector<Value>& Value::ToArray() {
  if (type_ != Type::Object) {
    Panic("Value::ToArray: the type must be Type::Object but not: " + Inspect());
  }
  if (!array_value_) {
    Panic("Value::ToArray: array_value_ must not be null");
  }
  return *array_value_;
}

std::shared_ptr<ArrayBuffer> Value::ToArrayBuffer() {
  if (type_ != Type::Object) {
    Panic("Value::ToArrayBuffer: the type must be Type::Object but not: " + Inspect());
  }
  if (!object_value_) {
    Panic("Value::ToArrayBuffer: object_value_ must not be null");
  }
  return std::static_pointer_cast<ArrayBuffer>(object_value_);
}

std::string Value::Inspect() const {
  switch (type_) {
  case Type::Null:
    return "null";
  case Type::Undefined:
    return "undefined";
  case Type::Bool:
    return ToBool() ? "true" : "false";
  case Type::Number:
    return std::to_string(ToNumber());
  case Type::String:
    return ToString();
  case Type::Object:
    if (IsArray()) {
      std::string str = "[";
      for (auto& v : *array_value_) {
        str += v.Inspect() + " ";
      }
      if (array_value_->size()) {
        str.resize(str.size()-1);
      }
      str += "]";
      return str;
    }
    if (IsObject()) {
      return ToObject().Inspect();
    }
    return "(object)";
  default:
    Panic("invalid type: " + std::to_string(static_cast<int>(type_)));
  }
  return "";
}

Object::~Object() = default;

Value Object::Get(const std::string& key) {
  Panic("Object::Get is not implemented: this: " + Inspect() + ", key: " + key);
  return Value{};
}

void Object::Set(const std::string& key, Value value) {
  Panic("Object::Set is not implemented: this: " + Inspect() + ", key: " + key + ", value: " + value.Inspect());
}

void Object::Delete(const std::string& key) {
  Panic("Object::Delete is not implemented: this: " + Inspect() + ", key: " + key);
}

Value Object::Invoke(Value self, std::vector<Value> args) {
  // TODO: Make this a pure virtual function?
  Panic("Object::Invoke is not implemented: this: " + Inspect() + ", self: " + self.Inspect());
  return Value{};
};

Value Object::New(std::vector<Value> args) {
  // TODO: Make this a pure virtual function?
  Panic("Object::New is not implemented: this: " + Inspect());
  return Value{};
};

BytesSpan Object::ToBytes() {
  return BytesSpan{};
}

std::string Object::Inspect() const {
  return ToString();
}

ArrayBuffer::ArrayBuffer(size_t size)
    : data_(size) {
}

size_t ArrayBuffer::ByteLength() const {
  return data_.size();
}

Value ArrayBuffer::Get(const std::string& key) {
  if (key == "byteLength") {
    return Value{static_cast<double>(ByteLength())};
  }
  return Value{};
}

bool ArrayBuffer::IsBytes() const {
  return true;
}

BytesSpan ArrayBuffer::ToBytes() {
  return BytesSpan{&*data_.begin(), data_.size()};
}

std::string ArrayBuffer::ToString() const {
  return "ArrayBuffer";
}

TypedArray::TypedArray(size_t size)
    : array_buffer_{std::make_shared<ArrayBuffer>(size)},
      length_{size} {
}

TypedArray::TypedArray(std::shared_ptr<ArrayBuffer> arrayBuffer, size_t offset, size_t length)
    : array_buffer_{arrayBuffer},
      offset_{offset},
      length_{length} {
}

Value TypedArray::Get(const std::string& key) {
  if (key == "byteLength") {
    return Value{static_cast<double>(length_)};
  }
  if (key == "byteOffset") {
    return Value{static_cast<double>(offset_)};
  }
  if (key == "buffer") {
    return Value{array_buffer_};
  }
  return Value{};
}

void TypedArray::Set(const std::string& key, Value value) {
  if (key == "byteLength") {
    length_ = static_cast<size_t>(value.ToNumber());
    return;
  }
  if (key == "byteOffset") {
    offset_ = static_cast<size_t>(value.ToNumber());
    return;
  }
  if (key == "buffer") {
    array_buffer_ = value.ToArrayBuffer();
    return;
  }
  Panic("TypedArray::Set: invalid key: " + key);
}

bool TypedArray::IsBytes() const {
  return true;
}

BytesSpan TypedArray::ToBytes() {
  auto bs = array_buffer_->ToBytes();
  return BytesSpan{bs.begin() + offset_, length_};
}

std::string TypedArray::ToString() const {
  return "TypedArray";
}

Uint8Array::Uint8Array(size_t size)
    : TypedArray(size) {
}

Uint8Array::Uint8Array(std::shared_ptr<ArrayBuffer> arrayBuffer, size_t offset, size_t length)
    : TypedArray(arrayBuffer, offset, length) {
}

std::string Uint8Array::ToString() const {
  return "Uint8Array";
}

Float32Array::Float32Array(size_t size)
    : TypedArray(size*4) {
}

Float32Array::Float32Array(std::shared_ptr<ArrayBuffer> arrayBuffer, size_t offset, size_t length)
    : TypedArray(arrayBuffer, offset*4, length*4) {
}

std::string Float32Array::ToString() const {
  return "Float32Array";
}

DictionaryValues::DictionaryValues() {
}

DictionaryValues::DictionaryValues(const std::map<std::string, Value>& dict)
    : dict_{dict} {
}

Value DictionaryValues::Get(const std::string& key) {
  auto it = dict_.find(key);
  if (it == dict_.end()) {
    return Value{};
  }
  return it->second;
}

void DictionaryValues::Set(const std::string& key, Value object) {
  dict_[key] = object;
}

void DictionaryValues::Delete(const std::string& key) {
  dict_.erase(key);
}

std::string DictionaryValues::ToString() const {
  return "DictionaryValues";
}

std::string DictionaryValues::Inspect() const {
  std::string str = "{";
  for (auto& kv : dict_) {
    str += kv.first + ":" + kv.second.Inspect() + " ";
  }
  if (dict_.size()) {
    str.resize(str.size()-1);
  }
  str += "}";
  return str;
}

Function::Function(Object::Func fn)
    : Function(fn, {}) {
}

Function::Function(Object::Func fn, Value self)
    : fn_(fn),
      self_(self) {
}

Value Function::Get(const std::string& key) {
  if (key == "bind") {
    return Value{std::make_shared<Function>(
      [this](Value self, std::vector<Value> args) -> Value {
        return Value{std::make_shared<Function>(fn_, args[0])};
      })};
  }
  return Object::Get(key);
}

Value Function::Invoke(Value self, std::vector<Value> args) {
  return fn_(self_, args);
}

Value Value::Global() {
  static Value global = MakeGlobal();
  return global;
}

Value Value::MakeGlobal() {
  std::shared_ptr<Constructor> arr = std::make_shared<Constructor>("Array",
    [](Value self, std::vector<Value> args) -> Value {
      // TODO: Implement this.
      return Value{};
    });
  std::shared_ptr<Constructor> obj = std::make_shared<Constructor>("Object",
    [](Value self, std::vector<Value> args) -> Value {
      if (args.size() == 1) {
        Panic("new Object(" + args[0].Inspect() + ") is not implemented");
      }
      return Value{std::make_shared<DictionaryValues>()};
    });

  std::shared_ptr<Constructor> arrayBuffer = std::make_shared<Constructor>("ArrayBuffer",
    [](Value self, std::vector<Value> args) -> Value {
      if (args.size() == 0) {
        Panic("new ArrayBuffer() is not implemented");
      }
      if (args.size() == 1) {
        Value vlen = args[0];
        if (!vlen.IsNumber()) {
          Panic("new ArrayBuffer(" + args[0].Inspect() + ") is not implemented");
        }
        size_t len = static_cast<size_t>(vlen.ToNumber());
        return Value{std::make_shared<ArrayBuffer>(len)};
      }
      Panic("new ArrayBuffer with " + std::to_string(args.size()) + " args is not implemented");
      return Value{};
    });

  std::shared_ptr<Constructor> u8 = std::make_shared<Constructor>("Uint8Array",
    [](Value self, std::vector<Value> args) -> Value {
      if (args.size() == 0) {
        return Value{std::make_shared<Uint8Array>(0)};
      }
      if (args.size() == 1) {
        if (args[0].IsNumber()) {
          size_t len = static_cast<size_t>(args[0].ToNumber());
          return Value{std::make_shared<Uint8Array>(len)};
        }
        if (args[0].IsObject()) {
          std::shared_ptr<ArrayBuffer> ab = args[0].ToArrayBuffer();
          auto u8 = std::make_shared<Uint8Array>(ab, 0, ab->ByteLength());
          return Value{u8};
        }
        Panic("new Uint8Array(" + args[0].Inspect() + ") is not implemented");
        return Value{};
      }
      if (args.size() == 3) {
        if (!args[0].IsObject()) {
          Panic("new Uint8Array's first argument must be an ArrayBuffer but " + args[0].Inspect());
        }
        if (!args[1].IsNumber()) {
          Panic("new Uint8Array's second argument must be a number but " + args[1].Inspect());
        }
        if (!args[2].IsNumber()) {
          Panic("new Uint8Array's third argument must be a number but " + args[2].Inspect());
        }
        std::shared_ptr<ArrayBuffer> ab = args[0].ToArrayBuffer();
        size_t offset = static_cast<size_t>(args[1].ToNumber());
        size_t length = static_cast<size_t>(args[2].ToNumber());
        auto u8 = std::make_shared<Uint8Array>(ab, offset, length);
        return Value{u8};
      }
      Panic("new Uint8Array with " + std::to_string(args.size()) + " args is not implemented");
      return Value{};
    });

  std::shared_ptr<Constructor> f32 = std::make_shared<Constructor>("Float32Array",
    [](Value self, std::vector<Value> args) -> Value {
      if (args.size() == 0) {
        return Value{std::make_shared<Float32Array>(0)};
      }
      if (args.size() == 1) {
        if (!args[0].IsObject()) {
          Panic("new Float32Array's first argument must be an ArrayBuffer but " + args[0].Inspect());
        }
        std::shared_ptr<ArrayBuffer> ab = args[0].ToArrayBuffer();
        auto f32 = std::make_shared<Float32Array>(ab, 0, ab->ByteLength()/4);
        return Value{f32};
      }
      if (args.size() == 3) {
        if (!args[0].IsObject()) {
          Panic("new Float32Array's first argument must be an ArrayBuffer but " + args[0].Inspect());
        }
        if (!args[1].IsNumber()) {
          Panic("new Float32Array's second argument must be a number but " + args[1].Inspect());
        }
        if (!args[2].IsNumber()) {
          Panic("new Float32Array's third argument must be a number but " + args[2].Inspect());
        }
        std::shared_ptr<ArrayBuffer> ab = args[0].ToArrayBuffer();
        size_t offset = static_cast<size_t>(args[1].ToNumber());
        size_t length = static_cast<size_t>(args[2].ToNumber());
        auto f32 = std::make_shared<Float32Array>(ab, offset, length);
        return Value{f32};
      }
      Panic("new Float32Array with " + std::to_string(args.size()) + " args is not implemented");
      return Value{};
    });

  std::shared_ptr<Constructor> date = std::make_shared<Constructor>("Date",
    [](Value self, std::vector<Value> args) -> Value {
      return Value{std::make_shared<Date>()};
    });

  Value getRandomValues{std::make_shared<Function>(
    [](Value self, std::vector<Value> args) -> Value {
      BytesSpan bs = args[0].ToBytes();
      // TODO: Use cryptographically strong random values instead of std::random_device.
      static std::random_device rd;
      std::uniform_int_distribution<uint8_t> dist(0, 255);
      for (size_t i = 0; i < bs.size(); i++) {
        bs[i] = dist(rd);
      }
      return Value{};
    })};
  std::shared_ptr<DictionaryValues> crypto = std::make_shared<DictionaryValues>(std::map<std::string, Value>{
    {"getRandomValues", getRandomValues},
  });

  static Value& writeObjectsToStdout = *new Value(std::make_shared<Function>(
    [](Value self, std::vector<Value> args) -> Value {
      WriteObjects(std::cout, args);
      return Value{};
    }));
  static Value& writeObjectsToStderr = *new Value(std::make_shared<Function>(
    [](Value self, std::vector<Value> args) -> Value {
      WriteObjects(std::cerr, args);
      return Value{};
    }));
  std::shared_ptr<DictionaryValues> console = std::make_shared<DictionaryValues>(std::map<std::string, Value>{
    {"error", writeObjectsToStderr},
    {"debug", writeObjectsToStderr},
    {"info", writeObjectsToStdout},
    {"log", writeObjectsToStdout},
    {"warm", writeObjectsToStderr},
  });

  std::shared_ptr<Function> fetch = std::make_shared<Function>(
    [](Value self, std::vector<Value> args) -> Value {
      // TODO: Implement this.
      return Value{};
    });

  static std::shared_ptr<FS> fs = std::make_shared<FS>();
  static std::shared_ptr<Process> process = std::make_shared<Process>();

  std::shared_ptr<DictionaryValues> global = std::make_shared<DictionaryValues>(std::map<std::string, Value>{
    {"Array", Value{arr}},
    {"Object", Value{obj}},
    {"ArrayBuffer", Value{arrayBuffer}},
    {"Uint8Array", Value{u8}},
    {"Float32Array", Value{f32}},
    {"Date", Value{date}},
    {"console", Value{console}},
    {"crypto", Value{crypto}},
    {"fetch", Value{fetch}},
    {"fs", Value{fs}},
    {"process", Value{process}},
  });

  return Value{global};
}

Value Value::ReflectGet(Value target, const std::string& key) {
  if (target.IsUndefined()) {
    Panic("get on undefined (key: " + key + ") is forbidden");
    return Value{};
  }
  if (target.IsNull()) {
    Panic("get on null (key: " + key + ") is forbidden");
    return Value{};
  }
  if (target.IsObject()) {
    return target.ToObject().Get(key);
  }
  if (target.IsArray()) {
    int idx = std::stoi(key);
    if (idx > 0 || (idx == 0 && key == "0")) {
      return target.ToArray()[idx];
    }
  }
  Panic(target.Inspect() + "." + key + " not found");
  return Value{};
}

void Value::ReflectSet(Value target, const std::string& key, Value value) {
  if (target.IsUndefined()) {
    Panic("set on undefined (key: " + key + ") is forbidden");
  }
  if (target.IsNull()) {
    Panic("set on null (key: " + key + ") is forbidden");
  }
  if (target.IsObject()) {
    target.ToObject().Set(key, value);
    return;
  }
  Panic(target.Inspect() + "." + key + " cannot be set");
}

void Value::ReflectDelete(Value target, const std::string& key) {
  if (target.IsUndefined()) {
    Panic("delete on undefined (key: " + key + ") is forbidden");
  }
  if (target.IsNull()) {
    Panic("delete on null (key: " + key + ") is forbidden");
  }
  if (target.IsObject()) {
    target.ToObject().Delete(key);
    return;
  }
  Panic(target.Inspect() + "." + key + " cannot be deleted");
}

Value Value::ReflectConstruct(Value target, std::vector<Value> args) {
  if (target.IsUndefined()) {
    Panic("new on undefined is forbidden");
    return Value{};
  }
  if (target.IsNull()) {
    Panic("new on null is forbidden");
    return Value{};
  }
  if (target.IsObject()) {
    Object& t = target.ToObject();
    if (!t.IsConstructor()) {
      Panic(t.ToString() + " is not a constructor");
      return Value{};
    }
    return t.New(args);
  }
  Panic("new " + target.Inspect() + "(" + JoinObjects(args) + ") cannot be called");
  return Value{};
}

Value Value::ReflectApply(Value target, Value self, std::vector<Value> args) {
  if (target.IsUndefined()) {
    Panic("apply on undefined is forbidden");
    return Value{};
  }
  if (target.IsNull()) {
    Panic("apply on null is forbidden");
    return Value{};
  }
  if (target.IsObject()) {
    Object& t = target.ToObject();
    if (t.IsConstructor()) {
      Panic(t.ToString() + " is a constructor");
      return Value{};
    }
    return t.Invoke(self, args);
  }
  Panic(target.Inspect() + "(" + JoinObjects(args) + ") cannot be called");
  return Value{};
}

Constructor::Constructor(const std::string& name, Object::Func fn)
    : name_(name),
      fn_(fn) {
}

Value Constructor::New(std::vector<Value> args) {
  return fn_(Value{}, args);
}

std::string Constructor::ToString() const {
  return name_;
}

}
`))
