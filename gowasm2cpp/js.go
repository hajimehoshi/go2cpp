// SPDX-License-Identifier: Apache-2.0

package gowasm2cpp

import (
	"os"
	"path/filepath"
	"text/template"
)

func writeJS(dir string, incpath string, namespace string) error {
	{
		f, err := os.Create(filepath.Join(dir, "js.h"))
		if err != nil {
			return err
		}
		defer f.Close()

		if err := jsHTmpl.Execute(f, struct {
			IncludeGuard string
			IncludePath  string
			Namespace    string
		}{
			IncludeGuard: includeGuard(namespace) + "_JS_H",
			IncludePath:  incpath,
			Namespace:    namespace,
		}); err != nil {
			return err
		}
	}
	{
		f, err := os.Create(filepath.Join(dir, "js.cpp"))
		if err != nil {
			return err
		}
		defer f.Close()

		if err := jsCppTmpl.Execute(f, struct {
			IncludePath string
			Namespace   string
		}{
			IncludePath: incpath,
			Namespace:   namespace,
		}); err != nil {
			return err
		}
	}
	return nil
}

var jsHTmpl = template.Must(template.New("js.h").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#ifndef {{.IncludeGuard}}
#define {{.IncludeGuard}}

#include <deque>
#include <functional>
#include <iostream>
#include <map>
#include <memory>
#include <string>
#include <vector>

namespace {{.Namespace}} {

class Writer {
public:
  explicit Writer(std::ostream& out);
  void Write(const std::vector<uint8_t>& bytes);

private:
  std::ostream& out_;
  // TODO: std::queue should be enough?
  std::deque<uint8_t> buf_;
};

class IObject;

class Value {
public:
  enum class Type {
    Null,
    Undefined,
    Bool,
    Number,
    String,
    Object,
  };

  static Value Undefined();

  Value();
  explicit Value(bool b);
  explicit Value(double num);
  explicit Value(const char* str);
  explicit Value(const std::string& str);
  explicit Value(const std::vector<uint8_t>& bytes);
  explicit Value(std::shared_ptr<IObject> object);
  explicit Value(const std::vector<Value>& array);

  Value(const Value& rhs);
  Value& operator=(const Value& rhs);
  bool operator<(const Value& rhs) const;

  bool IsNull() const;
  bool IsUndefined() const;
  bool IsBool() const;
  bool IsNumber() const;
  bool IsString() const;
  bool IsBytes() const;
  bool IsObject() const;
  bool IsArray() const;

  bool ToBool() const;
  double ToNumber() const;
  std::string ToString() const;
  std::vector<uint8_t>& ToBytes();
  const std::vector<uint8_t>& ToBytes() const;
  IObject& ToObject();
  const IObject& ToObject() const;
  std::vector<Value>& ToArray();

  std::string Inspect() const;

private:
  explicit Value(Type type);
  Value(Type type, double num);

  Type type_ = Type::Null;
  double num_value_ = 0;
  std::shared_ptr<std::vector<uint8_t>> bytes_value_;
  std::shared_ptr<IObject> object_value_;
  std::shared_ptr<std::vector<Value>> array_value_;
};

class IObject {
public:
  using Func = std::function<Value (Value, std::vector<Value>)>;

  virtual ~IObject();
  virtual Value Get(const std::string& key);
  virtual void Set(const std::string& key, Value value);
  virtual void Delete(const std::string& key);

  virtual bool IsFunction() const { return false; }
  virtual bool IsConstructor() const { return false; }
  virtual Value Invoke(Value self, std::vector<Value> args);
  virtual Value New(std::vector<Value> args);

  virtual std::string ToString() const {
    // TODO: Make this a pure virtual function.
    return "";
  }
};

class DictionaryValues : public IObject {
public:
  DictionaryValues();
  explicit DictionaryValues(const std::map<std::string, Value>& dict);
  Value Get(const std::string& key) override;
  void Set(const std::string& key, Value value) override;
  void Delete(const std::string& key) override;

private:
  std::map<std::string, Value> dict_;
};

class Enosys : public IObject {
public:
  explicit Enosys(const std::string& name);
  Value Get(const std::string& key) override;

private:
  std::string name_;
};

class FS {
public:
  FS();
  Value Write(Value self, std::vector<Value> args);

private:
  Writer stdout_;
  Writer stderr_;
};

class FuncObject : public IObject {
public:
  explicit FuncObject(IObject::Func fn);

  bool IsFunction() const override { return true; }
  bool IsConstructor() const override { return false; }
  Value Invoke(Value self, std::vector<Value> args) override;

private:
  IObject::Func fn_;
};

class Constructor : public IObject {
public:
  Constructor(const std::string& name, IObject::Func fn);

  bool IsFunction() const override { return true; }
  bool IsConstructor() const override { return true; }
  Value New(std::vector<Value> args) override;

private:
  std::string name_;
  IObject::Func fn_;
};

class JSObject : public IObject {
public:
  using JSFunc = std::function<Value (Value, std::vector<Value>)>;

  static std::shared_ptr<IObject> Global();

  static Value ReflectGet(Value target, const std::string& key);
  static void ReflectSet(Value target, const std::string& key, Value value);
  static void ReflectDelete(Value target, const std::string& key);
  static Value ReflectConstruct(Value target, std::vector<Value> args);
  static Value ReflectApply(Value target, Value self, std::vector<Value> args);

  // IObject:
  bool IsFunction() const override;
  bool IsConstructor() const override;
  Value Get(const std::string& key) override;
  void Set(const std::string& key, Value value) override;
  void Delete(const std::string& key) override;
  Value Invoke(Value self, std::vector<Value> args) override;
  Value New(std::vector<Value> args) override;

  std::string ToString() const override;

private:
  static std::shared_ptr<IObject> MakeGlobal();

  const std::string name_ = "(JSObject)";
  std::unique_ptr<IObject> values_ = nullptr;
  JSFunc fn_;
  const bool ctor_ = false;
};

}

#endif  // {{.IncludeGuard}}
`))

var jsCppTmpl = template.Must(template.New("js.cpp").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#include "{{.IncludePath}}js.h"

#include <algorithm>
#include <cassert>
#include <cstdlib>
#include <random>
#include <tuple>

namespace {{.Namespace}} {

namespace {

void error(const std::string& msg) {
  std::cerr << msg << std::endl;
  assert(false);
  std::exit(1);
}

std::string JoinObjects(const std::vector<Value>& objs) {
  std::string str;
  for (int i = 0; i < objs.size(); i++) {
    str += objs[i].Inspect();
    if (i < objs.size() - 1) {
      str += ", ";
    }
  }
  return str;
}

void WriteObjects(std::ostream& out, const std::vector<Value>& objs) {
  std::vector<std::string> inspects(objs.size());
  for (int i = 0; i < objs.size(); i++) {
    out << objs[i].Inspect();
    if (i < objs.size() - 1) {
      out << ", ";
    }
  }
  out << std::endl;
}

}  // namespace

Writer::Writer(std::ostream& out)
    : out_{out} {
}

void Writer::Write(const std::vector<uint8_t>& bytes) {
  buf_.insert(buf_.end(), bytes.begin(), bytes.end());
  for (;;) {
    auto it = std::find(buf_.begin(), buf_.end(), '\n');
    if (it == buf_.end()) {
      break;
    }
    std::string str(buf_.begin(), it);
    out_ << str << std::endl;
    ++it;
    buf_.erase(buf_.begin(), it);
  }
}

Value Value::Undefined() {
  static Value& undefined = *new Value(Type::Undefined);
  return undefined;
}

Value::Value() = default;

Value::Value(bool b)
    : type_{Type::Bool},
      num_value_{static_cast<double>(b)}{
}

Value::Value(double num)
    : type_{Type::Number},
      num_value_{num} {
}

Value::Value(const char* str)
    : Value{std::string(str)} {
}

Value::Value(const std::string& str)
    : type_{Type::String},
      bytes_value_{std::make_shared<std::vector<uint8_t>>(str.begin(), str.end())} {
}

Value::Value(const std::vector<uint8_t>& bytes)
    : type_{Type::Object},
      bytes_value_{std::make_shared<std::vector<uint8_t>>(bytes.begin(), bytes.end())} {
}

Value::Value(std::shared_ptr<IObject> object)
    : type_{Type::Object},
      object_value_{object} {
}

Value::Value(const std::vector<Value>& array)
    : type_{Type::Object},
      array_value_{std::make_shared<std::vector<Value>>(array.begin(), array.end())} {
}

Value::Value(const Value& rhs) = default;

Value& Value::operator=(const Value& rhs) = default;

bool Value::operator<(const Value& rhs) const {
  return std::tie(type_, num_value_, bytes_value_, object_value_, array_value_) <
      std::tie(rhs.type_, rhs.num_value_, rhs.bytes_value_, rhs.object_value_, rhs.array_value_);
}

Value::Value(Type type)
    : type_{type} {
}

Value::Value(Type type, double num)
    : type_{type},
      num_value_{num} {
}

bool Value::IsNull() const {
  return type_ == Type::Null;
}

bool Value::IsUndefined() const {
  return type_ == Type::Undefined;
}

bool Value::IsBool() const {
  return type_ == Type::Bool;
}

bool Value::IsNumber() const {
  return type_ == Type::Number;
}

bool Value::IsString() const {
  return type_ == Type::String;
}

bool Value::IsBytes() const {
  return type_ == Type::Object && !object_value_ && !array_value_;
}

bool Value::IsObject() const {
  return type_ == Type::Object && !!object_value_;
}

bool Value::IsArray() const {
  return type_ == Type::Object && !!array_value_;
}

bool Value::ToBool() const {
  if (type_ != Type::Bool) {
    error("Value::ToBool: the type must be Type::Bool but not: " + Inspect());
  }
  return static_cast<bool>(num_value_);
}

double Value::ToNumber() const {
  if (type_ != Type::Number) {
    error("Value::ToNumber: the type must be Type::Number but not: " + Inspect());
  }
  return num_value_;
}

std::string Value::ToString() const {
  if (type_ != Type::String) {
    error("Value::ToString: the type must be Type::String but not: " + Inspect());
  }
  if (!bytes_value_) {
    error("Value::ToString: bytes_value_ must not be null");
  }
  return std::string(bytes_value_->begin(), bytes_value_->end());
}

std::vector<uint8_t>& Value::ToBytes() {
  if (type_ != Type::Object) {
    error("Value::ToBytes: the type must be Type::Object but not: " + Inspect());
  }
  if (!bytes_value_) {
    error("Value::ToBytes: bytes_value_ must not be null");
  }
  return *bytes_value_;
}

const std::vector<uint8_t>& Value::ToBytes() const {
  if (type_ != Type::Object) {
    error("Value::ToBytes: the type must be Type::Object but not: " + Inspect());
  }
  if (!bytes_value_) {
    error("Value::ToBytes: bytes_value_ must not be null");
  }
  return *bytes_value_;
}

IObject& Value::ToObject() {
  if (type_ != Type::Object) {
    error("Value::ToObject: the type must be Type::Object but not: " + Inspect());
  }
  if (!object_value_) {
    error("Value::ToObject: object_value_ must not be null");
  }
  return *object_value_;
}

const IObject& Value::ToObject() const {
  if (type_ != Type::Object) {
    error("Value::ToObject: the type must be Type::Object but not: " + Inspect());
  }
  if (!object_value_) {
    error("Value::ToObject: object_value_ must not be null");
  }
  return *object_value_;
}

std::vector<Value>& Value::ToArray() {
  if (type_ != Type::Object) {
    error("Value::ToArray: the type must be Type::Object but not: " + Inspect());
  }
  if (!array_value_) {
    error("Value::ToArray: array_value_ must not be null");
  }
  return *array_value_;
}

std::string Value::Inspect() const {
  switch (type_) {
  case Type::Null:
    return "null";
  case Type::Undefined:
    return "undefined";
  case Type::Bool:
    return ToBool() ? "true" : "false";
  case Type::Number:
    return std::to_string(ToNumber());
  case Type::String:
    return ToString();
  case Type::Object:
    if (IsObject()) {
      return ToObject().ToString();
    }
    return "(object)";
  default:
    error("invalid type: " + std::to_string(static_cast<int>(type_)));
  }
  return "";
}

IObject::~IObject() = default;

Value IObject::Get(const std::string& key) {
  error("IObject::Get is not implemented");
  return Value{};
}

void IObject::Set(const std::string& key, Value value) {
  error("IObject::Set is not implemented");
}

void IObject::Delete(const std::string& key) {
  error("IObject::Delete is not implemented");
}

Value IObject::Invoke(Value self, std::vector<Value> args) {
  // TODO: Make this a pure virtual function?
  error("IObject::Invoke is not implemented");
  return Value{};
};

Value IObject::New(std::vector<Value> args) {
  // TODO: Make this a pure virtual function?
  error("IObject::New is not implemented");
  return Value{};
};

DictionaryValues::DictionaryValues() {
}

DictionaryValues::DictionaryValues(const std::map<std::string, Value>& dict)
    : dict_{dict} {
}

Value DictionaryValues::Get(const std::string& key) {
  auto it = dict_.find(key);
  if (it == dict_.end()) {
    return Value{};
  }
  return it->second;
}

void DictionaryValues::Set(const std::string& key, Value object) {
  dict_[key] = object;
}

void DictionaryValues::Delete(const std::string& key) {
  dict_.erase(key);
}

Enosys::Enosys(const std::string& name)
    : name_(name) {
}

Value Enosys::Get(const std::string& key) {
  if (key == "message") {
    return Value{name_ + " not implemented"};
  }
  if (key == "code") {
    return Value{"ENOSYS"};
  }
  return Value{};
}

FS::FS()
    : stdout_{std::cout},
      stderr_{std::cerr} {
}

Value FS::Write(Value self, std::vector<Value> args) {
  int fd = (int)(args[0].ToNumber());
  std::vector<uint8_t>& buf = args[1].ToBytes();
  int offset = (int)(args[2].ToNumber());
  int length = (int)(args[3].ToNumber());
  Value position = args[4];
  Value callback = args[5];
  if (offset != 0 || length != buf.size()) {
    JSObject::ReflectApply(callback, Value{}, std::vector<Value>{ Value{std::make_shared<Enosys>("write")} });
    return Value{};
  }
  if (!position.IsNull()) {
    JSObject::ReflectApply(callback, Value{}, std::vector<Value>{ Value{std::make_shared<Enosys>("write")} });
    return Value{};
  }
  switch (fd) {
  case 1:
    stdout_.Write(buf);
    break;
  case 2:
    stderr_.Write(buf);
    break;
  default:
    JSObject::ReflectApply(callback, Value{}, std::vector<Value>{ Value{std::make_shared<Enosys>("write")} });
    break;
  }
  JSObject::ReflectApply(callback, Value{}, std::vector<Value>{ Value{}, Value{static_cast<double>(buf.size())} });
  return Value{};
}

FuncObject::FuncObject(IObject::Func fn)
    : fn_(fn) {
}

Value FuncObject::Invoke(Value self, std::vector<Value> args) {
  return fn_(Value::Undefined(), args);
}

std::shared_ptr<IObject> JSObject::Global() {
  static std::shared_ptr<IObject> global = MakeGlobal();
  return global;
}

std::shared_ptr<IObject> JSObject::MakeGlobal() {
  std::shared_ptr<Constructor> arr = std::make_shared<Constructor>("Array",
    [](Value self, std::vector<Value> args) -> Value {
      // TODO: Implement this.
      return Value{};
    });
  std::shared_ptr<Constructor> obj = std::make_shared<Constructor>("Object",
    [](Value self, std::vector<Value> args) -> Value {
      if (args.size() == 1) {
        error("new Object(" + args[0].Inspect() + ") is not implemented");
      }
      return Value{std::make_shared<DictionaryValues>()};
    });

  std::shared_ptr<Constructor> arrayBuffer = std::make_shared<Constructor>("ArrayBuffer",
    [](Value self, std::vector<Value> args) -> Value {
      if (args.size() == 0) {
        error("new ArrayBuffer() is not implemented");
      }
      if (args.size() == 1) {
        Value len = args[0];
        if (!len.IsNumber()) {
          error("new Uint8Array(" + args[0].Inspect() + ") is not implemented");
        }
        Value v = Value{std::vector<uint8_t>(static_cast<int>(len.ToNumber()))};
        // TODO: Add functions and properties like byteLength.
        return v;
      }
      error("new ArrayBuffer with " + std::to_string(args.size()) + " args is not implemented");
      return Value{};
    });

  std::shared_ptr<Constructor> u8 = std::make_shared<Constructor>("Uint8Array",
    [](Value self, std::vector<Value> args) -> Value {
      if (args.size() == 0) {
        return Value{std::vector<uint8_t>{}};
      }
      if (args.size() == 1) {
        Value len = args[0];
        if (!len.IsNumber()) {
          error("new Uint8Array(" + args[0].Inspect() + ") is not implemented");
        }
        return Value{std::vector<uint8_t>(static_cast<int>(len.ToNumber()))};
      }
      error("new Uint8Array with " + std::to_string(args.size()) + " args is not implemented");
      return Value{};
    });

  Value getRandomValues{std::make_shared<FuncObject>(
    [](Value self, std::vector<Value> args) -> Value {
      std::vector<uint8_t>& bs = args[0].ToBytes();
      // TODO: Use cryptographically strong random values instead of std::random_device.
      static std::random_device rd;
      std::uniform_int_distribution<uint8_t> dist(0, 255);
      for (int i = 0; i < bs.size(); i++) {
        bs[i] = dist(rd);
      }
      return Value{};
    })};
  std::shared_ptr<DictionaryValues> crypto = std::make_shared<DictionaryValues>(std::map<std::string, Value>{
    {"getRandomValues", getRandomValues},
  });

  static Value& writeObjectsToStdout = *new Value(std::make_shared<FuncObject>(
    [](Value self, std::vector<Value> args) -> Value {
      WriteObjects(std::cout, args);
      return Value{};
    }));
  static Value& writeObjectsToStderr = *new Value(std::make_shared<FuncObject>(
    [](Value self, std::vector<Value> args) -> Value {
      WriteObjects(std::cerr, args);
      return Value{};
    }));
  std::shared_ptr<DictionaryValues> console = std::make_shared<DictionaryValues>(std::map<std::string, Value>{
    {"error", writeObjectsToStderr},
    {"debug", writeObjectsToStderr},
    {"info", writeObjectsToStdout},
    {"log", writeObjectsToStdout},
    {"warm", writeObjectsToStderr},
  });

  std::shared_ptr<FuncObject> fetch = std::make_shared<FuncObject>(
    [](Value self, std::vector<Value> args) -> Value {
      // TODO: Implement this.
      return Value{};
    });

  static FS& fsimpl = *new FS();
  std::shared_ptr<DictionaryValues> fs = std::make_shared<DictionaryValues>(std::map<std::string, Value>{
    {"constants", Value{std::make_shared<DictionaryValues>(std::map<std::string, Value>{
        {"O_WRONLY", Value{-1.0}},
        {"O_RDWR", Value{-1.0}},
        {"O_CREAT", Value{-1.0}},
        {"O_TRUNC", Value{-1.0}},
        {"O_APPEND", Value{-1.0}},
        {"O_EXCL", Value{-1.0}},
      })}},
    {"write", Value{std::make_shared<FuncObject>(
      [](Value self, std::vector<Value> args) -> Value {
        return fsimpl.Write(self, args);
      })}},
  });

  std::shared_ptr<DictionaryValues> process = std::make_shared<DictionaryValues>(std::map<std::string, Value>{
    {"pid", Value{-1.0}},
    {"ppid", Value{-1.0}},
  });

  std::shared_ptr<DictionaryValues> global = std::make_shared<DictionaryValues>(std::map<std::string, Value>{
    {"Array", Value{arr}},
    {"Object", Value{obj}},
    {"ArrayBuffer", Value{arrayBuffer}},
    {"Uint8Array", Value{u8}},
    {"console", Value{console}},
    {"crypto", Value{crypto}},
    {"fetch", Value{fetch}},
    {"fs", Value{fs}},
    {"process", Value{process}},
  });

  global->Set("window", Value{global});

  return global;
}

Value JSObject::ReflectGet(Value target, const std::string& key) {
  if (target.IsUndefined()) {
    error("get on undefined (key: " + key + ") is forbidden");
    return Value{};
  }
  if (target.IsNull()) {
    error("get on null (key: " + key + ") is forbidden");
    return Value{};
  }
  if (target.IsObject()) {
    return target.ToObject().Get(key);
  }
  if (target.IsArray()) {
    int idx = std::stoi(key);
    if (idx > 0 || (idx == 0 && key == "0")) {
      return target.ToArray()[idx];
    }
  }
  error(target.Inspect() + "." + key + " not found");
  return Value{};
}

void JSObject::ReflectSet(Value target, const std::string& key, Value value) {
  if (target.IsUndefined()) {
    error("set on undefined (key: " + key + ") is forbidden");
  }
  if (target.IsNull()) {
    error("set on null (key: " + key + ") is forbidden");
  }
  if (target.IsObject()) {
    target.ToObject().Set(key, value);
    return;
  }
  error(target.Inspect() + "." + key + " cannot be set");
}

void JSObject::ReflectDelete(Value target, const std::string& key) {
  if (target.IsUndefined()) {
    error("delete on undefined (key: " + key + ") is forbidden");
  }
  if (target.IsNull()) {
    error("delete on null (key: " + key + ") is forbidden");
  }
  if (target.IsObject()) {
    target.ToObject().Delete(key);
    return;
  }
  error(target.Inspect() + "." + key + " cannot be deleted");
}

Value JSObject::ReflectConstruct(Value target, std::vector<Value> args) {
  if (target.IsUndefined()) {
    error("new on undefined is forbidden");
    return Value{};
  }
  if (target.IsNull()) {
    error("new on null is forbidden");
    return Value{};
  }
  if (target.IsObject()) {
    IObject& t = target.ToObject();
    if (!t.IsConstructor()) {
      error(t.ToString() + " is not a constructor");
      return Value{};
    }
    return t.New(args);
  }
  error("new " + target.Inspect() + "(" + JoinObjects(args) + ") cannot be called");
  return Value{};
}

Value JSObject::ReflectApply(Value target, Value self, std::vector<Value> args) {
  if (target.IsUndefined()) {
    error("apply on undefined is forbidden");
    return Value{};
  }
  if (target.IsNull()) {
    error("apply on null is forbidden");
    return Value{};
  }
  if (target.IsObject()) {
    IObject& t = target.ToObject();
    if (t.IsConstructor()) {
      error(t.ToString() + " is a constructor");
      return Value{};
    }
    return t.Invoke(self, args);
  }
  error(target.Inspect() + "(" + JoinObjects(args) + ") cannot be called");
  return Value{};
}

Constructor::Constructor(const std::string& name, IObject::Func fn)
    : name_(name),
      fn_(fn) {
}

Value Constructor::New(std::vector<Value> args) {
  return fn_(Value::Undefined(), args);
}

bool JSObject::IsFunction() const {
  return !!fn_;
}

bool JSObject::IsConstructor() const {
  return ctor_;
}

Value JSObject::Get(const std::string& key) {
  if (!values_) {
    error(ToString() + "." + key + " not found");
  }
  return values_->Get(key);
}

void JSObject::Set(const std::string& key, Value value) {
  if (!values_) {
    values_ = std::make_unique<DictionaryValues>(std::map<std::string, Value>{});
  }
  values_->Set(key, value);
}

void JSObject::Delete(const std::string& key) {
  if (!values_) {
    return;
  }
  values_->Delete(key);
}

Value JSObject::Invoke(Value self, std::vector<Value> args) {
  if (!fn_) {
    error(ToString() + " is not invokable since " + ToString() + " is not a function");
    return Value{};
  }
  if (ctor_) {
    error(ToString() + " is not invokable since " + ToString() + " is a constructor");
    return Value{};
  }
  return fn_(self, args);
}

Value JSObject::New(std::vector<Value> args) {
  if (!fn_) {
    error(ToString() + " is not invokable since " + ToString() + " is not a function");
    return Value{};
  }
  if (!ctor_) {
    error(ToString() + " is not invokable since " + ToString() + " is not a constructor");
    return Value{};
  }
  // TODO: What should the receiver be?
  return fn_(Value{}, args);
}

std::string JSObject::ToString() const {
  return name_;
}

}
`))
